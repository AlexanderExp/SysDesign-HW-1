{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "# ADR: Архитектура сервиса аренды пауэрбанков (команда 8)\n",
    "\n",
    "**Дата:** 20.11.2025\n",
    "**Состав команды:** Салахов Данияр, Фролов Александр, Юлдашев Сарвар, Майорова Марина\n",
    "**Команда:** 8\n",
    "**Group:** architecture / integration / data / billing\n",
    "**Статус:** proposed (на рассмотрении преподавателя)  \n",
    "\n",
    "---\n",
    "\n",
    "## Issue / Контекст и постановка задачи\n",
    "\n",
    "Нужно превратить учебную заготовку (скрипт с in-memory словарями и заглушками) в полноценную систему:\n",
    "\n",
    "- с **микросервисной архитектурой**;\n",
    "- с отдельной **БД**;\n",
    "- с учётом NFR по **Maintainability, Reliability, Scalability**;\n",
    "- с выполнением функциональных требований варианта команды 8.\n",
    "\n",
    "### Functional Requirements (FR)\n",
    "\n",
    "1. **Три основных handler’а:**\n",
    "   - `POST /rentals/quote` — посчитать оффер (цену, депозит, TTL оффера).\n",
    "   - `POST /rentals/start` — начать аренду по ранее полученному офферу.\n",
    "   - `POST /rentals/{order_id}/stop` — остановить аренду, вернуть итоговую сумму.\n",
    "   - Вспомогательная ручка: `GET /rentals/{order_id}/status` — статус аренды и накопленная стоимость.\n",
    "\n",
    "2. **Источники данных (через HTTP во внешний `external-stubs`):**\n",
    "   - `stations` — данные по станции.\n",
    "   - `tariffs` — тарифная зона.\n",
    "   - `users` — профиль пользователя (подписка/trusted).\n",
    "   - `configs` — конфигурация и feature-флаги.\n",
    "   - `payments` — удержание и списание денег.\n",
    "\n",
    "3. **Логика работы офферов:**\n",
    "   - Контроль **свежести оффера** (TTL).\n",
    "   - **Текущая накопленная стоимость** аренды.\n",
    "   - **Регулярные списания** в течение аренды.\n",
    "   - При невозможности списания — **навешивать долг**.\n",
    "   - **Периодические попытки списания долга** с бэкоффом.\n",
    "   - При достижении `R_BUYOUT` (платежи + долг) — **автовыкуп**, статус `BUYOUT`.\n",
    "\n",
    "### Non-Functional Requirements (NFR)\n",
    "\n",
    "**Maintainability**\n",
    "\n",
    "- Возможность добавлять новые источники данных и менять бизнес-логику без переписывания всего сервиса.\n",
    "- Чёткое разделение:\n",
    "  - бизнес-логики,\n",
    "  - работы с внешними сервисами,\n",
    "  - хранения данных,\n",
    "  - фоновых процессов (биллинг).\n",
    "\n",
    "**Reliability**\n",
    "\n",
    "- Источники разделены на:\n",
    "  - **Критичный**:\n",
    "    - `stations` — без станции аренду начать нельзя.\n",
    "  - **Некритичные** (должна быть деградация/фоллбэк):\n",
    "    - `configs` — при старте обязательна успешная загрузка; затем можно работать по старому конфигу.\n",
    "    - `tariffs` — LRU-кэш + TTL (старые данные > N минут не использовать).\n",
    "    - `users` — при недоступности — фоллбэк к «жадному» профилю (нет подписки, не trusted).\n",
    "    - `payments` — при недоступности аренда запускается, долг растёт.\n",
    "\n",
    "- Идемпотентность:\n",
    "  - повторный `/start` с тем же `Idempotency-Key` не создаёт дубликата аренды;\n",
    "  - повторный `/stop` не ломает финальный статус.\n",
    "\n",
    "**Scalability**\n",
    "\n",
    "Для нашей команды (номер 8) заданы параметры:\n",
    "\n",
    "- **X = 10** — внешняя нагрузка на создание аренды (`/rentals/start`) в RPS.\n",
    "- **Y = 10** — количество пользователей/исполнителей:\n",
    "  - каждый раз в минуту запрашивает статус => `Y/60` RPS на `/status`.\n",
    "- **Z = 1 kB** — размер хранения одного заказа (минимальный набор данных).\n",
    "\n",
    "Требование: система **линейно масштабируется** по X и Y, поддерживает горизонтальное масштабирование:\n",
    "\n",
    "- `rental-core` — через горизонтальный скейлинг,\n",
    "- `billing-worker` — через шардирование / несколько воркеров.\n",
    "\n",
    "---\n",
    "\n",
    "## Assumptions and Constraints\n",
    "\n",
    "**Предположения:**\n",
    "\n",
    "- Единственная основная БД — PostgreSQL.\n",
    "- Код пишется на Python, веб-фреймворк — FastAPI.\n",
    "- Внешние системы моделируются сервисом `external-stubs`.\n",
    "\n",
    "**Ограничения:**\n",
    "\n",
    "- Учебный проект — не вводим тяжёлые инфраструктурные компоненты (Kafka и т.п.), только то, что можно поднять `docker-compose`.\n",
    "- Все внешние интеграции — синхронные HTTP вызовы.\n",
    "- Храним только минимально необходимый набор данных, эквивалентный Z = 1 kB на заказ.\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "## Positions / Рассматриваемые варианты архитектуры\n",
    "\n",
    "В процессе проектирования мы явно зафиксировали несколько архитектурных позиций (вариантов), которые могли бы удовлетворить функциональные и нефункциональные требования (FR, NFR). Даже те варианты, которые формально выходят за рамки учебного задания, рассматривались, чтобы наполнить этот пункт ADR, требуемый по заданию. \n",
    "\n",
    "### Position A — Монолитный сервис `rental-service` с фоновыми задачами внутри\n",
    "\n",
    "**Идея.**  \n",
    "Один сервис `rental-service`, написанный на FastAPI, который одновременно:\n",
    "\n",
    "- обрабатывает все HTTP-запросы (`/rentals/quote`, `/start`, `/stop`, `/status`);\n",
    "- по внутреннему планировщику (cron/apscheduler/background tasks) выполняет периодический биллинг:\n",
    "  - пересчёт накопленной стоимости;\n",
    "  - попытки списания;\n",
    "  - обработку долгов и `R_BUYOUT`.\n",
    "\n",
    "Хранение данных — единая БД PostgreSQL с теми же сущностями (`rentals`, `quotes`, `payment_attempts`, `debts`, `idempotency_keys`).\n",
    "\n",
    "**Плюсы (почему вариант вообще рассматривался).**\n",
    "\n",
    "- Максимально простая инфраструктура:\n",
    "  - один кодовый репозиторий, один контейнер, один деплой;\n",
    "  - проще локальная разработка и отладка.\n",
    "- Все операции над арендами и биллингом происходят внутри одного процесса:\n",
    "  - нет сетевого взаимодействия между сервисами;\n",
    "  - нет распределённых транзакций, всё в рамках одной БД.\n",
    "\n",
    "**Минусы и ограничения.**\n",
    "\n",
    "- Фактически это монолит, что противоречит цели задания «построить микросервисную архитектуру».\n",
    "- Масштабирование по X и Y (нагрузка на `/start` и `/status`) ограничено:\n",
    "  - API-запросы и фоновые биллинговые задачи конкурируют за одни и те же ресурсы процесса;\n",
    "  - при росте нагрузки биллинг может «подъедать» CPU и память, увеличивая задержки HTTP-ответов.\n",
    "- Падает maintainability:\n",
    "  - в одном кодовом базисе смешиваются HTTP-слой, бизнес-логика аренды и периодическая денежная логика;\n",
    "  - сложнее выделять ответственность и тестировать компоненты по отдельности.\n",
    "\n",
    "**Вывод.**  \n",
    "Вариант A удобен как верхняя граница самого простого решения, но плохо соответствует требованиям к микросервисной архитектуре, масштабируемости и поддерживаемости, поэтому использовался только как отправная точка для сравнения.\n",
    "\n",
    "---\n",
    "\n",
    "### Position B — Два сервиса: `rental-core` + `billing-worker` с общей БД (текущее решение)\n",
    "\n",
    "**Идея.**  \n",
    "Разделить систему на два микросервиса:\n",
    "\n",
    "- `rental-core` — HTTP-API и состояние аренды:\n",
    "  - обрабатывает `/rentals/quote`, `/start`, `/stop`, `/status`, `/health`;\n",
    "  - обращается к внешним системам через слой клиентов;\n",
    "  - читает и пишет данные аренды в БД.\n",
    "- `billing-worker` — фоновый воркер:\n",
    "  - по таймеру обходит активные аренды;\n",
    "  - пересчитывает начисления;\n",
    "  - создаёт записи о попытках списания;\n",
    "  - ведёт долги и меняет статус аренды на `BUYOUT` при достижении `R_BUYOUT`.\n",
    "\n",
    "Оба сервиса используют **общую БД PostgreSQL** с единым набором таблиц.\n",
    "\n",
    "**Плюсы.**\n",
    "\n",
    "- Чёткое разделение ответственности:\n",
    "  - `rental-core` — синхронное пользовательское API;\n",
    "  - `billing-worker` — асинхронная денежная логика.\n",
    "- Простое горизонтальное масштабирование:\n",
    "  - `rental-core` stateless, можно поднимать несколько экземпляров за балансировщиком;\n",
    "  - количество экземпляров `billing-worker` можно увеличивать отдельно (шардирование по арендам или по времени).\n",
    "- Инфраструктура остаётся простой для учебного проекта:\n",
    "  - не нужны дополнительные брокеры сообщений или сложные компоненты;\n",
    "  - достаточно `docker-compose` с двумя сервисами и одной БД.\n",
    "- Хороший баланс между соответствием NFR (maintainability, reliability, scalability) и сложностью реализации.\n",
    "\n",
    "**Минусы и ограничения.**\n",
    "\n",
    "- Всё ещё единая БД — отсутствие изоляции данных между онлайн-операциями и биллингом:\n",
    "  - возможны конкурирующие блокировки (конкурентные апдейты по одной аренде);\n",
    "  - требуется аккуратно проектировать транзакции и уровни изоляции.\n",
    "\n",
    "---\n",
    "\n",
    "### Position C — `rental-core` + `billing-worker` + очередь сообщений (RabbitMQ / Redis Streams)\n",
    "\n",
    "**Идея.**  \n",
    "Сохранить разделение на `rental-core` и `billing-worker`, но добавить **явный асинхронный канал** взаимодействия:\n",
    "\n",
    "- `rental-core`:\n",
    "  - по событиям (создание аренды, изменение статуса, проблемы с оплатой) публикует сообщения в очередь или топик (например, RabbitMQ, Redis Streams);\n",
    "  - отвечает пользователю сразу после записи в БД и публикации события.\n",
    "- `billing-worker`:\n",
    "  - подписывается на события из очереди;\n",
    "  - на их основе обновляет `payment_attempts`, `debts`, статусы аренд;\n",
    "  - может хранить часть своего состояния отдельно (кэш долгов, счётчики ретраев).\n",
    "\n",
    "БД остаётся общей или частично общей; ключевое отличие — появление брокера сообщений.\n",
    "\n",
    "**Плюсы.**\n",
    "\n",
    "- Более слабое зацепление между сервисами:\n",
    "  - `billing-worker` реагирует на бизнес-события, а не читает БД «в лоб» по таймеру;\n",
    "  - легче добавлять новые потребители событий (например, сервис уведомлений).\n",
    "- Лучшая устойчивость к пикам нагрузки:\n",
    "  - очередь буферизует всплески (при росте X/Y растёт длина очереди, но не ломается API);\n",
    "  - `billing-worker` можно масштабировать, читая очередь параллельно.\n",
    "\n",
    "**Минусы и ограничения.**\n",
    "\n",
    "- Существенно более сложная инфраструктура:\n",
    "  - появляется брокер сообщений, который нужно инсталлировать, конфигурировать и мониторить;\n",
    "  - сложнее локальная разработка и деплой (ещё один сервис в `docker-compose`).\n",
    "- Для учебного задания есть явное ограничение «не вводить тяжёлые инфраструктурные компоненты (Kafka и т.п.)»:\n",
    "  - формально RabbitMQ/Redis Streams можно поднять, но это усложняет стенд и отвлекает от основной цели.\n",
    "- Увеличивается когнитивная сложность:\n",
    "  - появляется асинхронная обработка, ретраи на уровне очереди, dead-letter механизмы и т.д.\n",
    "\n",
    "**Вывод.**  \n",
    "Вариант C даёт более «производственную» архитектуру с явной событийной шиной, но инфраструктурно тяжелее и избыточен для заданной учебной нагрузки X=10, Y=10, Z=1 kB.\n",
    "\n",
    "---\n",
    "\n",
    "\n",
    "## Argument / Обоснование выбора\n",
    "\n",
    "При выборе архитектуры мы сравнивали варианты A, B и C по нескольким критериям:\n",
    "\n",
    "- соответствие учебному заданию (микросервисная архитектура, ограниченная инфраструктура);\n",
    "- поддерживаемость (maintainability);\n",
    "- надёжность (reliability);\n",
    "- масштабируемость (scalability) по X и Y;\n",
    "- сложность реализации и сопровождения.\n",
    "\n",
    "### Сравнение Position A vs Position B\n",
    "\n",
    "- **Микросервисность.**\n",
    "  - A: фактически монолит с фоновыми задачами → не отражает идеи микросервисной архитектуры.\n",
    "  - B: даёт два независимых сервиса с разделением ответственности (API и биллинг).\n",
    "\n",
    "- **Масштабируемость.**\n",
    "  - A: API-запросы и биллинг конкурируют за один процесс/пул потоков; рост X/Y ухудшает латентность для всех.\n",
    "  - B: `rental-core` и `billing-worker` масштабируются независимо; можно поднимать больше реплик только там, где растёт нагрузка.\n",
    "\n",
    "- **Поддерживаемость.**\n",
    "  - A: в одном кодовом дереве смешаны HTTP-слой, бизнес-логика и периодические задачи.\n",
    "  - B: денежная логика вынесена в отдельный воркер; проще менять биллинг, не трогая API, и наоборот.\n",
    "\n",
    "- **Сложность.**\n",
    "  - A: инфраструктурно проще, но сложнее логически (много ролей у одного сервиса).\n",
    "  - B: появляется второй сервис и деплой, но общий уровень сложности для команды остаётся приемлемым.\n",
    "\n",
    "**Вывод:** Position B даёт значимый выигрыш в масштабируемости и поддерживаемости по сравнению с Position A, при умеренном увеличении инфраструктурной сложности.\n",
    "\n",
    "### Сравнение Position B vs Position C\n",
    "\n",
    "- **Инфраструктура.**\n",
    "  - B: требуется только две службы и одна БД → укладывается в ограничение «поднять через docker-compose».\n",
    "  - C: добавляется брокер сообщений (RabbitMQ/Redis Streams и т.п.), который нужно устанавливать, настраивать и мониторить.\n",
    "\n",
    "- **Масштабируемость и надёжность.**\n",
    "  - B: биллинг работает по таймеру, что достаточно для заданной нагрузки (X=10, Y=10); пики нагрузок обрабатываются за счёт масштабирования воркера и БД.\n",
    "  - C: даёт более гибкую обработку пиков и явную событийную модель, но это преимущество не критично при текущих требованиях.\n",
    "\n",
    "- **Сложность разработки.**\n",
    "  - B: взаимодействие через общую БД, меньше концепций для команды.\n",
    "  - C: нужно проектировать формат сообщений, обработку ретраев, ошибочные сообщения (DLQ) и т.п.\n",
    "\n",
    "**Вывод:** Position C архитектурно «красивее» и ближе к промышленным системам, но существенно усложняет инфраструктуру и выходит за рамки учебных ограничений. Для заданной нагрузки преимущества не окупают усложнение.\n",
    "\n",
    "### Итоговое решение\n",
    "\n",
    "Учитывая:\n",
    "\n",
    "- требование продемонстрировать микросервисную архитектуру;\n",
    "- ограничение по инфраструктуре (только то, что можно поднять через `docker-compose`);\n",
    "- учебную нагрузку X=10 RPS, Y=10 пользователей и малый объём данных Z=1 kB на заказ;\n",
    "\n",
    "мы выбрали **Position B** (два сервиса `rental-core` и `billing-worker` с общей БД PostgreSQL) как оптимальный баланс между соответствием требованиям и сложностью реализации.\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "## Related requirements / Связанные требования\n",
    "\n",
    "### Функциональные требования (FR)\n",
    "\n",
    "- **FR-1: Handlers `/rentals/quote`, `/start`, `/stop`, `/status`.**  \n",
    "  Реализуются в сервисе `rental-core` как HTTP-эндпоинты. Сервис обращается к БД и внешним источникам через слой клиентов.\n",
    "\n",
    "- **FR-2: Интеграция с внешними системами (`stations`, `tariffs`, `users`, `configs`, `payments`).**  \n",
    "  Инкапсулирована в модуле клиентов (`clients.py`) в `rental-core` и, при необходимости, в `billing-worker`. Там же реализуются кэши и стратегии деградации.\n",
    "\n",
    "- **FR-3: Логика офферов и биллинга (TTL оффера, накопленная стоимость, регулярные списания, долги, `R_BUYOUT`).**  \n",
    "  - Офферы (`quotes`) создаются и валидируются в `rental-core`.  \n",
    "  - Регулярные списания, управление долгами и смена статуса на `BUYOUT` выполняются в `billing-worker` на основе таблиц `rentals`, `payment_attempts`, `debts`.\n",
    "\n",
    "### Нефункциональные требования (NFR)\n",
    "\n",
    "- **NFR-Maintainability (поддерживаемость).**  \n",
    "  - Разделение на `rental-core` и `billing-worker` уменьшает связность и упрощает изменение биллинга без изменений API.  \n",
    "  - Слой клиентов отделяет бизнес-логику от интеграций.\n",
    "\n",
    "- **NFR-Reliability (надёжность).**  \n",
    "  - Чётко определены критичный (`stations`) и некритичные источники с фоллбэками (`configs`, `tariffs`, `users`, `payments`).  \n",
    "  - Идемпотентность `/start` и корректная обработка повторных `/stop` защищают от дублей и рассинхронизации.\n",
    "\n",
    "- **NFR-Scalability (масштабируемость).**  \n",
    "  - `rental-core` stateless и может масштабироваться горизонтально под рост X и Y.  \n",
    "  - `billing-worker` можно масштабировать независимо (несколько воркеров, шардирование по арендам).  \n",
    "  - Нагрузка на БД оценена и остаётся в пределах комфортных значений для одной PostgreSQL.\n",
    "\n",
    "\n",
    "## Related principles / Связанные принципы\n",
    "\n",
    "При принятии решения использовались следующие явные/неявные архитектурные принципы:\n",
    "\n",
    "- **P1: \"Простота инфраструктуры\".**  \n",
    "  Используем только те компоненты, которые можно поднять через `docker-compose` в учебной среде (без Kafka и тяжёлых брокеров).\n",
    "\n",
    "- **P2: \"Чёткие границы ответственности\".**  \n",
    "  HTTP-API (`rental-core`) не содержит периодической биллинговой логики; фоновая обработка вынесена в `billing-worker`.\n",
    "\n",
    "- **P3: \"Деградация лучше полного отказа\".**  \n",
    "  Некритичные внешние источники (`tariffs`, `users`, `configs`, `payments`) имеют кэш или фоллбэки; при их недоступности система работает в деградированном режиме.\n",
    "\n",
    "- **P4: \"Линейная масштабируемость по X и Y\".**  \n",
    "  Архитектура должна позволять увеличивать количество инстансов `rental-core` и `billing-worker` без серьёзных переделок.\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "## Decision / Архитектурное решение\n",
    "\n",
    "### Микросервисное разбиение\n",
    "\n",
    "**Решение:** система разделена на три основных компонента.\n",
    "\n",
    "1. **`rental-core`**\n",
    "   - FastAPI-сервис (`services/rental-core/app/main.py`).\n",
    "   - Отвечает за:\n",
    "     - `POST /rentals/quote`\n",
    "     - `POST /rentals/start`\n",
    "     - `POST /rentals/{order_id}/stop`\n",
    "     - `GET /rentals/{order_id}/status`\n",
    "     - `GET /health`\n",
    "   - Хранит и читает состояние аренды в БД.\n",
    "   - Не ходит во внешние сервисы напрямую — использует слой клиентов (`clients.py`), где инкапсулированы HTTP-вызовы, кэши и фоллбэки.\n",
    "\n",
    "2. **`billing-worker`**\n",
    "   - Отдельный сервис (`services/billing-worker/main.py`), работающий как фоновый воркер.\n",
    "   - Периодически (каждые `BILLING_TICK_SEC` секунд):\n",
    "     - находит активные аренды (`status='ACTIVE'`);\n",
    "     - пересчитывает начисленную сумму;\n",
    "     - пытается списать деньги;\n",
    "     - вешает долг при неуспехе;\n",
    "     - ретраит погашение исторического долга с бэкоффом;\n",
    "     - при достижении `R_BUYOUT` завершает аренду со статусом `BUYOUT`.\n",
    "\n",
    "3. **`external-stubs`**\n",
    "   - Отдельный сервис, предоставляющий HTTP-заглушки всех внешних источников:\n",
    "     - `/station-data`\n",
    "     - `/tariff`\n",
    "     - `/user-profile`\n",
    "     - `/configs`\n",
    "     - `/eject-powerbank`\n",
    "     - `/hold-money-for-order`\n",
    "     - `/clear-money-for-order`\n",
    "   - Имитирует реальные внешние системы для отработки стратегий деградации и кэширования.\n",
    "\n",
    "### Хранение данных\n",
    "\n",
    "**Решение:** единая БД PostgreSQL (в docker-compose; в юнит-тестах — `sqlite+pysqlite`) с пятью ключевыми сущностями:\n",
    "\n",
    "- `rentals` — состояние аренды;\n",
    "- `idempotency_keys` — поддержка идемпотентности `/start`;\n",
    "- `quotes` — одноразовые офферы с TTL;\n",
    "- `payment_attempts` — аудит всех попыток списаний;\n",
    "- `debts` — текущее состояние долга по арендам.\n",
    "\n",
    "Обе службы (`rental-core` и `billing-worker`) используют одну и ту же схему (ORM-модели синхронизированы).\n",
    "\n",
    "### Работа с внешними источниками и надёжность\n",
    "\n",
    "**Решение по критичности источников:**\n",
    "\n",
    "- `stations` — **критичный**:\n",
    "  - при недоступности станций — запрос аварийно завершается (`5xx`), аренду начать нельзя.\n",
    "\n",
    "- `configs` — **некритичный, но обязательный на старте**:\n",
    "  - при старте сервиса конфиг должен быть успешно загружен; в противном случае сервис не поднимается;\n",
    "  - далее используется закэшированное значение + периодическое обновление.\n",
    "\n",
    "- `tariffs` — **некритичный, с кэшем**:\n",
    "  - используется LRU-кэш с TTL (`TARIFF_TTL_SEC`);\n",
    "  - устаревшие данные удаляются и пере-запрашиваются;\n",
    "  - при временной недоступности тарифов возможны ошибки ответа, но процесс в целом не падает.\n",
    "\n",
    "- `users` — **некритичный, с фоллбэком**:\n",
    "  - при недоступности профиля — используется жадный фоллбэк (нет подписки, пользователь не trusted).\n",
    "\n",
    "- `payments` — **некритичный**:\n",
    "  - при недоступности платежей на старте аренды депозит превращается в долг;\n",
    "  - при ошибках в биллинге растёт долг, который потом ретраится.\n",
    "\n",
    "### Биллинг\n",
    "\n",
    "**Решение:** вынести денежную логику в отдельный сервис-воркер:\n",
    "\n",
    "- регулярные списания выполняет только `billing-worker`;\n",
    "- API (`rental-core`) остаётся быстрым и простым (создание/закрытие аренды и чтение статуса);\n",
    "- денежное состояние (`total_amount`, `debt`, `BUYOUT`) рассчитывается централизованно.\n",
    "\n",
    "---\n",
    "\n",
    "## Схема системы и потоки запросов\n",
    "\n",
    "### Основные последовательности запросов\n",
    "\n",
    "**1) `POST /rentals/quote`**\n",
    "\n",
    "* `rental-core`:\n",
    "\n",
    "  * вызывает через клиентов:\n",
    "\n",
    "    * `/station-data` → `stations`;\n",
    "    * `/tariff` → `tariffs`;\n",
    "    * `/user-profile` → `users`;\n",
    "  * считает цену, free_period, депозит;\n",
    "  * записывает строку в `quotes` с `expires_at = now() + 60s`;\n",
    "  * возвращает `quote_id` и параметры.\n",
    "\n",
    "**2) `POST /rentals/start`**\n",
    "\n",
    "* проверка идемпотентности по `Idempotency-Key` в `idempotency_keys`:\n",
    "\n",
    "  * если ключ есть — вернуть сохранённый ответ;\n",
    "* проверка квоты:\n",
    "\n",
    "  * загрузка из `quotes` по `quote_id`;\n",
    "  * проверка `expires_at > now()`; иначе 4xx;\n",
    "  * поглощение квоты (delete);\n",
    "* `clients.eject_powerbank(station_id)` → `/eject-powerbank`;\n",
    "* создание записи `Rental` со статусом `\"ACTIVE\"`;\n",
    "* попытка `hold_money_for_order`:\n",
    "\n",
    "  * при успехе — депозит удержан;\n",
    "  * при ошибке — депозит добавляется в `debts` как долг;\n",
    "* сохранение ответа в `idempotency_keys`.\n",
    "\n",
    "**3) Периодическая обработка биллингом**\n",
    "\n",
    "* `billing-worker` по таймеру:\n",
    "\n",
    "  * выбирает активные `rentals`;\n",
    "  * считает `due` по тарифу и времени;\n",
    "  * суммирует уже оплаченные `PaymentAttempt`;\n",
    "  * читает долг `Debts`;\n",
    "  * до-снимает деньги или гасит исторический долг;\n",
    "  * при достижении `R_BUYOUT` ставит статус `BUYOUT` и `finished_at`.\n",
    "\n",
    "**4) `GET /rentals/{order_id}/status`**\n",
    "\n",
    "* `rental-core` возвращает:\n",
    "\n",
    "  * `status` (`ACTIVE`, `FINISHED`, `BUYOUT`, …);\n",
    "  * `powerbank_id`;\n",
    "  * `total_amount`;\n",
    "  * `debt`.\n",
    "\n",
    "**5) `POST /rentals/{order_id}/stop`**\n",
    "\n",
    "* если аренда уже `FINISHED` — возврат текущего состояния;\n",
    "* иначе:\n",
    "\n",
    "  * выставляется `FINISHED`, `finished_at = now()`;\n",
    "  * выполняется `clear_money_for_order` (финальное списание/разбор депозита);\n",
    "  * возможные ошибки платежей ведут к долгам, но не отменяют завершение аренды.\n",
    "\n",
    "---\n",
    "\n",
    "## Основные сущности БД\n",
    "\n",
    "1. **`rentals`** — аренда:\n",
    "\n",
    "   * `id` — PK, UUID;\n",
    "   * `user_id`;\n",
    "   * `powerbank_id`;\n",
    "   * `price_per_hour`;\n",
    "   * `free_period_min`;\n",
    "   * `deposit`;\n",
    "   * `status` — `\"ACTIVE\"`, `\"FINISHED\"`, `\"BUYOUT\"`, …;\n",
    "   * `total_amount` — уже списанная сумма;\n",
    "   * `started_at`, `finished_at`.\n",
    "\n",
    "2. **`idempotency_keys`** — идемпотентность:\n",
    "\n",
    "   * `key` — PK (`Idempotency-Key`);\n",
    "   * `scope` (например, `\"start\"`);\n",
    "   * `user_id`;\n",
    "   * `response_json` — сериализованный ответ на повторную выдачу.\n",
    "\n",
    "3. **`quotes`** — офферы:\n",
    "\n",
    "   * `id` (`quote_id`) — PK;\n",
    "   * `user_id`;\n",
    "   * `station_id`;\n",
    "   * `price_per_hour`, `free_period_min`, `deposit`;\n",
    "   * `expires_at` — TTL оффера;\n",
    "   * `created_at`.\n",
    "\n",
    "4. **`payment_attempts`** — попытки списаний:\n",
    "\n",
    "   * `id` — PK;\n",
    "   * `rental_id`;\n",
    "   * `amount`;\n",
    "   * `success` (bool);\n",
    "   * `error` (nullable text);\n",
    "   * `created_at`.\n",
    "\n",
    "5. **`debts`** — долги:\n",
    "\n",
    "   * `rental_id` — PK;\n",
    "   * `amount_total` — текущий долг;\n",
    "   * `updated_at`;\n",
    "   * `attempts` — число неуспешных попыток списания;\n",
    "   * `last_attempt_at`.\n",
    "\n",
    "---\n",
    "\n",
    "## Расчёт нагрузки\n",
    "\n",
    "### Нагрузка по HTTP-handler’ам\n",
    "\n",
    "Задано:\n",
    "\n",
    "* X = 10 RPS на создание аренды (`/rentals/start`);\n",
    "* Y = 10 пользователей, каждый раз в минуту вызывает `/status`.\n",
    "\n",
    "Пусть система в steady-state.\n",
    "\n",
    "Приближения:\n",
    "\n",
    "* **`POST /rentals/quote`**\n",
    "  Предположим, к каждому `start` предшествует `quote`:\n",
    "  `RPS_quote ≈ X = 10`.\n",
    "\n",
    "* **`POST /rentals/start`**\n",
    "  `RPS_start ≈ X = 10`.\n",
    "\n",
    "* **`POST /rentals/{order_id}/stop`**\n",
    "  В среднем число стопов примерно равно числу стартов, но равномерно размазано во времени.\n",
    "  Для оценки берем `RPS_stop ~ 10` (можно заложиться меньше).\n",
    "\n",
    "* **`GET /rentals/{order_id}/status`**\n",
    "  `RPS_status = Y / 60 = 10 / 60 ≈ 0.17 RPS`.\n",
    "\n",
    "Итого по HTTP (оценочно):\n",
    "\n",
    "* write-операции (quote / start / stop): **20–30 RPS**;\n",
    "* read-операции (`status`): ~ **0.2 RPS**.\n",
    "\n",
    "### Нагрузка на БД\n",
    "\n",
    "На один `start`:\n",
    "\n",
    "* чтение квоты (`quotes`) — 1 read;\n",
    "* удаление квоты — 1 write;\n",
    "* создание `rental` — 1 write;\n",
    "* создание `idempotency_key` — 1 write;\n",
    "* при падении `hold_money_for_order` — доп. 1 write в `debts`.\n",
    "\n",
    "Итого на X = 10 RPS по `/start` имеем:\n",
    "\n",
    "* чтения: ~10 RPS;\n",
    "* записи: ~30–40 RPS (с учётом `quote` и стопов).\n",
    "\n",
    "На один `tick_once` в `billing-worker`:\n",
    "\n",
    "* чтение списка активных `rentals` — 1 read;\n",
    "* на каждую аренду:\n",
    "\n",
    "  * read из `payment_attempts`;\n",
    "  * read из `debts`;\n",
    "  * при изменениях: write в `payment_attempts`, `debts`, иногда update `rentals`.\n",
    "\n",
    "Даже при десятках RPS на запись и сопоставимом количестве чтений, текущая нагрузка для PostgreSQL комфортна и масштабируется через реплики для чтения.\n",
    "\n",
    "### Расчёт хранения\n",
    "\n",
    "При Z = 1 kB:\n",
    "\n",
    "* один заказ ≈ 1 kB в `rentals` + небольшой overhead в `payment_attempts` и `debts`.\n",
    "\n",
    "При 10 RPS и работе системы 1 час:\n",
    "\n",
    "* за час: `10 * 3600 = 36 000` заказов → ≈ 36 MB;\n",
    "* за сутки: ~864 000 заказов → ≈ 864 MB, то есть около 1 GB.\n",
    "\n",
    "Стратегии оптимизации:\n",
    "\n",
    "* архивирование старых аренд;\n",
    "* очистка `payment_attempts` и `debts` после полного погашения.\n",
    "\n",
    "---\n",
    "\n",
    "## Implications / Плюсы и возможные доработки\n",
    "\n",
    "**Плюсы решения:**\n",
    "\n",
    "* Чёткое разделение зон ответственности:\n",
    "\n",
    "  * `rental-core` — HTTP-API и бизнес-состояние;\n",
    "  * `billing-worker` — денежная логика и периодические операции;\n",
    "  * `external-stubs` — внешний мир.\n",
    "* Простая горизонтальная масштабируемость:\n",
    "\n",
    "  * `rental-core` stateless, масштабируется по X и Y;\n",
    "  * биллинг можно шардировать.\n",
    "* NFR:\n",
    "\n",
    "  * maintainability — модульная структура, отдельные клиенты, понятные модели;\n",
    "  * reliability — деградация по некритичным источникам, строгие правила для критичного `stations`;\n",
    "  * scalability — расчёт нагрузки и архитектура под горизонтальный скейлинг.\n",
    "\n",
    "## Notes / Open questions\n",
    "\n",
    "* При росте нагрузки шардирование аренд или очередь задач\n",
    "* Подключена полноценная система метрик (Prometheus/Grafana)\n",
    "* Схема взаимодействия микросервисов и БД через mermaid\n",
    "* Circuit breaker\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "## Related artifacts / Связанные артефакты\n",
    "\n",
    "Архитектурное решение опирается на следующие артефакты и влияет на них:\n",
    "\n",
    "- **Диаграмма взаимодействия микросервисов (Mermaid).**  \n",
    "  Показывает потоки запросов между `rental-core`, `billing-worker`, `external-stubs` и БД.\n",
    "\n",
    "- **`docker-compose.yml`.**  \n",
    "  Описывает запуск `rental-core`, `billing-worker`, `external-stubs` и PostgreSQL в локальном окружении.\n",
    "\n",
    "- **Отчёт о выполненной работе**  \n",
    "\n",
    "- **Детали реализации**  "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.12.5 64-bit ('3.12.5')",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.12.5"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "e765bc9a329b799a3f9a07d5b1a3662c5553ec672b9179afc9ef51d7ac00afe4"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
