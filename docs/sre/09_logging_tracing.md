# 09. Логирование и трассировка

> **Сложность:** ⭐⭐ Средний уровень
> **Вопросы из списка:** 31, 32, 33, 34, 35

---

## Вопрос 31: Что такое логи? Влияние на ресурсы

### Что такое логи?

**Логи** — это текстовые записи о событиях в системе с временными метками.

```
┌─────────────────────────────────────────────────────────┐
│                       ЛОГИ                              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  2024-01-15 10:23:45.123 INFO  [auth-service] User      │
│  login successful: user_id=12345                        │
│                                                         │
│  2024-01-15 10:23:45.456 ERROR [payment-service]        │
│  Payment failed: order_id=67890, reason=insufficient_   │
│  funds                                                  │
│                                                         │
│  2024-01-15 10:23:45.789 DEBUG [inventory-service]      │
│  Checking stock for product_id=111, quantity=5          │
│                                                         │
│  Компоненты лога:                                       │
│  • Timestamp — когда произошло                          │
│  • Level — важность (DEBUG, INFO, WARN, ERROR)          │
│  • Source — откуда (сервис, класс, функция)             │
│  • Message — что произошло                              │
│  • Context — дополнительные данные                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Уровни логирования

```
┌─────────────────────────────────────────────────────────┐
│                  УРОВНИ ЛОГИРОВАНИЯ                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  TRACE  ──► Самый детальный (каждый шаг)                │
│    │                                                    │
│    ▼                                                    │
│  DEBUG  ──► Отладочная информация (для разработки)      │
│    │                                                    │
│    ▼                                                    │
│  INFO   ──► Важные события (запуск, остановка)          │
│    │                                                    │
│    ▼                                                    │
│  WARN   ──► Предупреждения (что-то подозрительное)      │
│    │                                                    │
│    ▼                                                    │
│  ERROR  ──► Ошибки (что-то сломалось)                   │
│    │                                                    │
│    ▼                                                    │
│  FATAL  ──► Критические ошибки (приложение падает)      │
│                                                         │
│  Рекомендация для Production:                           │
│  • Обычно: INFO и выше                                  │
│  • При отладке: DEBUG                                   │
│  • TRACE — только локально                              │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Влияние логирования на ресурсы

```
┌─────────────────────────────────────────────────────────┐
│              ВЛИЯНИЕ НА РЕСУРСЫ                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. CPU                                                 │
│     • Форматирование строк                              │
│     • Сериализация объектов                             │
│     • Особенно дорого: JSON, stack traces               │
│                                                         │
│  2. ПАМЯТЬ                                              │
│     • Буферы логов                                      │
│     • Строковые объекты                                 │
│     • Очереди асинхронных логгеров                      │
│                                                         │
│  3. ДИСК                                                │
│     • Запись на диск (I/O)                              │
│     • Хранение логов (место)                            │
│     • Ротация логов                                     │
│                                                         │
│  4. СЕТЬ                                                │
│     • Отправка в централизованное хранилище             │
│     • ELK, Loki, CloudWatch                             │
│                                                         │
│  Пример влияния:                                        │
│  ┌─────────────────────────────────────────────────┐    │
│  │ Уровень    │ Логов/сек │ CPU    │ Disk I/O     │    │
│  ├────────────┼───────────┼────────┼──────────────┤    │
│  │ ERROR      │ 10        │ 0.1%   │ 1 KB/s       │    │
│  │ INFO       │ 1,000     │ 2%     │ 100 KB/s     │    │
│  │ DEBUG      │ 100,000   │ 20%    │ 10 MB/s      │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Вопрос 32: Структурированные vs неструктурированные логи

### Неструктурированные логи

```
┌─────────────────────────────────────────────────────────┐
│               НЕСТРУКТУРИРОВАННЫЕ ЛОГИ                  │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Просто текст:                                          │
│                                                         │
│  [2024-01-15 10:23:45] User john@example.com logged     │
│  in from IP 192.168.1.100                               │
│                                                         │
│  [2024-01-15 10:23:46] Processing order #12345 for      │
│  user 67890, total amount: $99.99                       │
│                                                         │
│  [2024-01-15 10:23:47] Error: Connection refused to     │
│  database server db-master.internal:5432                │
│                                                         │
│  ❌ Проблемы:                                           │
│  • Сложно парсить автоматически                         │
│  • Разный формат в разных сервисах                      │
│  • Трудно искать и фильтровать                          │
│  • Нельзя агрегировать                                  │
│                                                         │
│  Как найти все ошибки для user_id=67890?                │
│  → grep "67890" logs.txt | grep -i error                │
│  → Ненадёжно! Может найти order_id=67890                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Структурированные логи

```
┌─────────────────────────────────────────────────────────┐
│                СТРУКТУРИРОВАННЫЕ ЛОГИ                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  JSON формат:                                           │
│                                                         │
│  {                                                      │
│    "timestamp": "2024-01-15T10:23:45.123Z",             │
│    "level": "INFO",                                     │
│    "service": "auth-service",                           │
│    "event": "user_login",                               │
│    "user_id": 67890,                                    │
│    "email": "john@example.com",                         │
│    "ip": "192.168.1.100",                               │
│    "trace_id": "abc123"                                 │
│  }                                                      │
│                                                         │
│  {                                                      │
│    "timestamp": "2024-01-15T10:23:47.456Z",             │
│    "level": "ERROR",                                    │
│    "service": "payment-service",                        │
│    "event": "db_connection_failed",                     │
│    "error": "Connection refused",                       │
│    "host": "db-master.internal",                        │
│    "port": 5432,                                        │
│    "trace_id": "abc123"                                 │
│  }                                                      │
│                                                         │
│  ✅ Преимущества:                                       │
│  • Легко парсить                                        │
│  • Единый формат                                        │
│  • Точный поиск: user_id=67890                          │
│  • Агрегация: COUNT(*) WHERE level="ERROR"              │
│  • Корреляция по trace_id                               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Сравнение

| Аспект | Неструктурированные | Структурированные |
|--------|---------------------|-------------------|
| Читаемость человеком | ✅ Легко | ❌ Сложнее |
| Парсинг машиной | ❌ Сложно | ✅ Легко |
| Поиск и фильтрация | ❌ grep, regex | ✅ Точные запросы |
| Агрегация | ❌ Невозможно | ✅ COUNT, SUM |
| Размер | ✅ Меньше | ❌ Больше (JSON overhead) |
| Стандартизация | ❌ Каждый пишет как хочет | ✅ Единая схема |

### Рекомендация

```
┌─────────────────────────────────────────────────────────┐
│                   РЕКОМЕНДАЦИЯ                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Используй СТРУКТУРИРОВАННЫЕ логи!                      │
│                                                         │
│  Обязательные поля:                                     │
│  • timestamp — ISO 8601 (2024-01-15T10:23:45.123Z)      │
│  • level — DEBUG, INFO, WARN, ERROR                     │
│  • service — имя сервиса                                │
│  • message — описание события                           │
│  • trace_id — для корреляции (если есть)                │
│                                                         │
│  Дополнительные поля по контексту:                      │
│  • user_id, order_id, request_id                        │
│  • duration_ms — для измерения времени                  │
│  • error — описание ошибки                              │
│  • stack_trace — только для ERROR                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Вопрос 33: Ошибки в организации логирования

### Типичные ошибки

```
┌─────────────────────────────────────────────────────────┐
│                    ТИПИЧНЫЕ ОШИБКИ                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. СЛИШКОМ МНОГО ЛОГОВ                                 │
│     ─────────────────────                               │
│     ❌ Логируем каждую строку кода                      │
│     ❌ DEBUG в production                               │
│     ❌ Логируем в цикле                                 │
│                                                         │
│     for item in items:  # 1M items                      │
│         logger.debug(f"Processing {item}")  # 1M логов! │
│                                                         │
│  2. СЛИШКОМ МАЛО ЛОГОВ                                  │
│     ─────────────────────                               │
│     ❌ Нет логов в catch блоках                         │
│     ❌ Нет контекста (что за запрос? какой user?)       │
│                                                         │
│     try:                                                │
│         process()                                       │
│     except Exception:                                   │
│         pass  # ← Ошибка молча проглочена!              │
│                                                         │
│  3. ЧУВСТВИТЕЛЬНЫЕ ДАННЫЕ                               │
│     ─────────────────────                               │
│     ❌ Пароли в логах                                   │
│     ❌ Токены, API ключи                                │
│     ❌ Персональные данные (PII)                        │
│     ❌ Номера карт                                      │
│                                                         │
│     logger.info(f"User login: {password}")  # ОПАСНО!  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Ещё ошибки

```
┌─────────────────────────────────────────────────────────┐
│                  ЕЩЁ ОШИБКИ                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  4. НЕТ КОРРЕЛЯЦИИ                                      │
│     ─────────────────                                   │
│     ❌ Нет trace_id / request_id                        │
│     → Невозможно связать логи одного запроса            │
│                                                         │
│     Service A: "Processing request"                     │
│     Service B: "Received message"                       │
│     Service C: "Error occurred"                         │
│     → Какой запрос вызвал ошибку?!                      │
│                                                         │
│  5. СИНХРОННОЕ ЛОГИРОВАНИЕ                              │
│     ─────────────────────────                           │
│     ❌ Запись на диск блокирует поток                   │
│     → Замедляет обработку запросов                      │
│                                                         │
│     Решение: Асинхронные логгеры с буфером              │
│                                                         │
│  6. НЕТ РОТАЦИИ                                         │
│     ─────────────────                                   │
│     ❌ Логи растут бесконечно                           │
│     → Диск заполняется → система падает                 │
│                                                         │
│     Решение: logrotate, размер файла, время хранения    │
│                                                         │
│  7. НЕПРАВИЛЬНЫЙ УРОВЕНЬ                                │
│     ─────────────────────                               │
│     ❌ ERROR для некритичных событий                    │
│     ❌ INFO для отладки                                 │
│     → Шум в алертах, сложно найти реальные проблемы     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Чек-лист хорошего логирования

```
┌─────────────────────────────────────────────────────────┐
│                    ЧЕК-ЛИСТ                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  □ Структурированные логи (JSON)                        │
│  □ Единый формат во всех сервисах                       │
│  □ trace_id для корреляции                              │
│  □ Правильные уровни (INFO в prod, DEBUG для отладки)   │
│  □ Нет чувствительных данных                            │
│  □ Асинхронное логирование                              │
│  □ Ротация логов настроена                              │
│  □ Централизованное хранение (ELK, Loki)                │
│  □ Алерты на ERROR логи                                 │
│  □ Контекст в каждом логе (user_id, request_id)         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Вопрос 34: Log Sampling (сэмплирование логов)

### Что такое Log Sampling?

**Log Sampling** — это запись только части логов (например, каждого 10-го).

```
┌─────────────────────────────────────────────────────────┐
│                   LOG SAMPLING                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Без сэмплирования: 100,000 логов/сек                   │
│  │████████████████████████████████████████│             │
│                                                         │
│  С сэмплированием 10%: 10,000 логов/сек                 │
│  │████                                    │             │
│                                                         │
│  Экономия: 90% ресурсов!                                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Какие проблемы решает?

```
┌─────────────────────────────────────────────────────────┐
│                ПРОБЛЕМЫ, КОТОРЫЕ РЕШАЕТ                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. ОБЪЁМ ДАННЫХ                                        │
│     100K RPS × 1KB лог = 100 MB/сек = 8.6 TB/день!      │
│     С сэмплированием 1%: 86 GB/день                     │
│                                                         │
│  2. СТОИМОСТЬ                                           │
│     Cloud logging стоит денег за объём                  │
│     Меньше логов = меньше счёт                          │
│                                                         │
│  3. ПРОИЗВОДИТЕЛЬНОСТЬ                                  │
│     Меньше I/O                                          │
│     Меньше CPU на форматирование                        │
│     Меньше сетевого трафика                             │
│                                                         │
│  4. ШУМОПОДАВЛЕНИЕ                                      │
│     Легче найти важное в меньшем объёме                 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Стратегии сэмплирования

```
┌─────────────────────────────────────────────────────────┐
│                    СТРАТЕГИИ                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. RATE-BASED (по частоте)                             │
│     Записываем каждый N-й лог                           │
│                                                         │
│     if random() < 0.1:  # 10%                           │
│         log(message)                                    │
│                                                         │
│  2. HEAD-BASED (по началу)                              │
│     Решение принимается в начале запроса                │
│     Все логи запроса или ничего                         │
│                                                         │
│     request_id = generate_id()                          │
│     if should_sample(request_id):                       │
│         # Все логи этого запроса записываются           │
│                                                         │
│  3. TAIL-BASED (по результату)                          │
│     Решение принимается после завершения                │
│     Записываем если: ошибка, медленный, интересный      │
│                                                         │
│     if response.status >= 500 or duration > 1s:         │
│         flush_all_logs(request_id)                      │
│                                                         │
│  4. PRIORITY-BASED (по приоритету)                      │
│     ERROR — 100% (всегда)                               │
│     WARN — 50%                                          │
│     INFO — 10%                                          │
│     DEBUG — 1%                                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Что учитывать при сэмплировании

```
┌─────────────────────────────────────────────────────────┐
│                  ЧТО УЧИТЫВАТЬ                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. ОШИБКИ ВСЕГДА ЛОГИРУЕМ (100%)                       │
│     Нельзя пропустить ERROR и FATAL                     │
│                                                         │
│  2. СОХРАНЯЙ КОНТЕКСТ                                   │
│     Если сэмплируем запрос — все его логи или ничего    │
│     Иначе невозможно отследить flow                     │
│                                                         │
│  3. ЗАПИСЫВАЙ SAMPLE RATE                               │
│     {"sample_rate": 0.1, ...}                           │
│     Чтобы экстраполировать метрики                      │
│                                                         │
│  4. АДАПТИВНОЕ СЭМПЛИРОВАНИЕ                            │
│     Низкая нагрузка → 100%                              │
│     Высокая нагрузка → 1%                               │
│                                                         │
│  5. НЕ СЭМПЛИРУЙ РЕДКИЕ СОБЫТИЯ                         │
│     Если событие раз в час — не сэмплируй               │
│     Сэмплирование для частых событий                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Вопрос 35: Distributed Tracing (распределённая трассировка)

### Проблема: Запрос через много сервисов

```
┌─────────────────────────────────────────────────────────┐
│                     ПРОБЛЕМА                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Запрос пользователя проходит через 5 сервисов:         │
│                                                         │
│  User → API Gateway → Auth → Order → Inventory → DB     │
│                                                         │
│  Запрос медленный. Где проблема?                        │
│                                                         │
│  Логи:                                                  │
│  [auth] Request received                                │
│  [order] Processing order                               │
│  [inventory] Checking stock                             │
│  [order] Order created                                  │
│                                                         │
│  ❓ Какой запрос? Сколько времени на каждом этапе?      │
│  ❓ Где задержка?                                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Что такое Distributed Tracing?

**Distributed Tracing** — это отслеживание запроса через все сервисы.

```
┌─────────────────────────────────────────────────────────┐
│                 DISTRIBUTED TRACING                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Trace — полный путь запроса                            │
│  Span — одна операция внутри trace                      │
│                                                         │
│  Trace ID: abc-123                                      │
│  ─────────────────────────────────────────────────────  │
│                                                         │
│  ├─ Span: API Gateway (50ms)                            │
│  │   └─ Span: Auth Service (20ms)                       │
│  │       └─ Span: JWT Validation (5ms)                  │
│  │   └─ Span: Order Service (200ms)  ← ПРОБЛЕМА!        │
│  │       └─ Span: DB Query (150ms)   ← Медленный запрос │
│  │       └─ Span: Inventory Check (30ms)                │
│  │   └─ Span: Response (5ms)                            │
│                                                         │
│  Теперь видно: Order Service медленный из-за DB Query!  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Как это работает?

```
┌─────────────────────────────────────────────────────────┐
│                  КАК ЭТО РАБОТАЕТ                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. ГЕНЕРАЦИЯ TRACE ID                                  │
│     Первый сервис создаёт уникальный trace_id           │
│                                                         │
│  2. PROPAGATION (передача)                              │
│     trace_id передаётся в заголовках HTTP/gRPC          │
│                                                         │
│     HTTP Headers:                                       │
│     X-Trace-Id: abc-123                                 │
│     X-Span-Id: span-456                                 │
│     X-Parent-Span-Id: span-123                          │
│                                                         │
│  3. СОЗДАНИЕ SPANS                                      │
│     Каждый сервис создаёт span с:                       │
│     • trace_id (общий)                                  │
│     • span_id (уникальный)                              │
│     • parent_span_id (родитель)                         │
│     • start_time, end_time                              │
│     • tags (метаданные)                                 │
│                                                         │
│  4. ОТПРАВКА В COLLECTOR                                │
│     Spans отправляются в централизованное хранилище     │
│     Jaeger, Zipkin, Tempo, Datadog                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Визуализация в Jaeger

```
┌─────────────────────────────────────────────────────────┐
│                   JAEGER UI                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Trace: abc-123                      Total: 275ms       │
│  ─────────────────────────────────────────────────────  │
│                                                         │
│  │ api-gateway    ████████████████████████████  275ms   │
│  │   └ auth       ████                          20ms    │
│  │   └ order      ████████████████████          200ms   │
│  │       └ db     ██████████████                150ms   │
│  │       └ inv    ██████                        30ms    │
│  │   └ response   █                             5ms     │
│  │                                                      │
│  │ 0ms      50ms     100ms    150ms    200ms    275ms   │
│                                                         │
│  Видно: DB query занимает 55% времени!                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Инструменты

```
┌─────────────────────────────────────────────────────────┐
│                    ИНСТРУМЕНТЫ                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Open Source:                                           │
│  • Jaeger — популярный, от Uber                         │
│  • Zipkin — от Twitter                                  │
│  • Tempo — от Grafana                                   │
│                                                         │
│  Коммерческие:                                          │
│  • Datadog APM                                          │
│  • New Relic                                            │
│  • Dynatrace                                            │
│                                                         │
│  Стандарты:                                             │
│  • OpenTelemetry — единый стандарт                      │
│  • OpenTracing — устаревший                             │
│  • W3C Trace Context — стандарт заголовков              │
│                                                         │
│  Рекомендация: Используй OpenTelemetry!                 │
│  Один SDK для метрик, логов и трейсов                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Что трейсинг помогает найти?

```
┌─────────────────────────────────────────────────────────┐
│              ЧТО ПОМОГАЕТ НАЙТИ                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. УЗКИЕ МЕСТА (Bottlenecks)                           │
│     Какой сервис/операция занимает больше времени?      │
│                                                         │
│  2. ОШИБКИ                                              │
│     Где именно произошла ошибка в цепочке?              │
│                                                         │
│  3. ЗАВИСИМОСТИ                                         │
│     Какие сервисы вызывает этот сервис?                 │
│     Визуализация графа зависимостей                     │
│                                                         │
│  4. АНОМАЛИИ                                            │
│     Почему этот запрос медленнее других?                │
│     Сравнение трейсов                                   │
│                                                         │
│  5. N+1 ПРОБЛЕМЫ                                        │
│     100 последовательных запросов к БД                  │
│     Видно на трейсе как 100 spans                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Ключевые термины

| Термин | Определение |
|--------|-------------|
| **Лог** | Текстовая запись о событии с timestamp |
| **Уровень логирования** | Важность события (DEBUG, INFO, ERROR) |
| **Структурированные логи** | Логи в формате JSON с полями |
| **Log Sampling** | Запись только части логов |
| **Distributed Tracing** | Отслеживание запроса через сервисы |
| **Trace** | Полный путь запроса |
| **Span** | Одна операция внутри trace |
| **Trace ID** | Уникальный идентификатор запроса |
| **OpenTelemetry** | Стандарт для метрик, логов и трейсов |

---

## Что запомнить

1. **Структурированные логи** (JSON) лучше текстовых
2. **Всегда добавляй trace_id** для корреляции
3. **Не логируй чувствительные данные** (пароли, токены)
4. **Log sampling** экономит ресурсы, но ERROR всегда 100%
5. **Distributed tracing** показывает, где тормозит запрос
6. **OpenTelemetry** — единый стандарт, используй его

---

*Следующий файл: [10. Детектирование сбоев и алертинг](10_alerting_detection.md)*

