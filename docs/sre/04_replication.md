# 04. Репликация данных

> **Сложность:** ⭐⭐ Средний уровень
> **Вопросы из списка:** 18, 19, 20, 21, 22

---

## Вопрос 18: Цели репликации

### Что такое репликация?

**Репликация** — это копирование данных на несколько серверов (узлов).

```
┌─────────────┐
│   MASTER    │  ← Принимает записи
│  (Primary)  │
└──────┬──────┘
       │ Репликация
       ├────────────────┬────────────────┐
       ▼                ▼                ▼
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  REPLICA 1  │  │  REPLICA 2  │  │  REPLICA 3  │
│ (Secondary) │  │ (Secondary) │  │ (Secondary) │
└─────────────┘  └─────────────┘  └─────────────┘
       ↑                ↑                ↑
       └────────────────┴────────────────┘
              Обслуживают чтение
```

### Зачем нужна репликация?

#### 1. Высокая доступность (High Availability)

```
┌─────────────────────────────────────────────────────────┐
│                   ВЫСОКАЯ ДОСТУПНОСТЬ                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Без репликации:                                        │
│  ┌─────────┐                                            │
│  │ Master  │ ← Упал = СИСТЕМА НЕДОСТУПНА!               │
│  └─────────┘                                            │
│                                                         │
│  С репликацией:                                         │
│  ┌─────────┐     ┌─────────┐                            │
│  │ Master  │ ←── │ Replica │ ← Становится новым Master  │
│  │  УПАЛ   │     │   OK    │                            │
│  └─────────┘     └─────────┘                            │
│                                                         │
│  Результат: Система продолжает работать!                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Failover** — автоматическое переключение на реплику при падении мастера.

#### 2. Масштабирование чтения (Read Scaling)

```
┌─────────────────────────────────────────────────────────┐
│                 МАСШТАБИРОВАНИЕ ЧТЕНИЯ                  │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Проблема: 1 сервер не справляется с нагрузкой         │
│                                                         │
│  ┌─────────┐                                            │
│  │ Master  │ ← 10,000 запросов/сек = ПЕРЕГРУЗКА!        │
│  └─────────┘                                            │
│                                                         │
│  Решение: Распределить чтение по репликам               │
│                                                         │
│  ┌─────────┐     Записи (1,000/сек)                     │
│  │ Master  │◄────────────────────                       │
│  └────┬────┘                                            │
│       │                                                 │
│  ┌────┴────┬────────────┬────────────┐                  │
│  ▼         ▼            ▼            ▼                  │
│ Rep1     Rep2         Rep3         Rep4                 │
│ 2.5K     2.5K         2.5K         2.5K  чтений/сек     │
│                                                         │
│  Результат: Каждая реплика обрабатывает часть нагрузки  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 3. Географическое распределение (Geo-distribution)

```
┌─────────────────────────────────────────────────────────┐
│              ГЕОГРАФИЧЕСКОЕ РАСПРЕДЕЛЕНИЕ               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Москва              Нью-Йорк            Токио          │
│  ┌─────────┐         ┌─────────┐         ┌─────────┐    │
│  │ Master  │────────►│ Replica │────────►│ Replica │    │
│  └─────────┘         └─────────┘         └─────────┘    │
│      ▲                   ▲                   ▲          │
│   Клиенты             Клиенты             Клиенты       │
│   из РФ               из США              из Японии     │
│   (5ms)               (5ms)               (5ms)         │
│                                                         │
│  Вместо 200ms до Москвы — 5ms до локальной реплики!     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 4. Защита данных (Data Protection)

```
Реплика = резервная копия в реальном времени

┌─────────────┐         ┌─────────────┐
│   Master    │────────►│   Replica   │
│  Москва     │         │  Другой DC  │
└─────────────┘         └─────────────┘
      │                       │
   Пожар!                  Данные
   Данные                  сохранены!
   потеряны
```

### Сводка целей репликации

| Цель | Что решает | Пример |
|------|------------|--------|
| **High Availability** | Отказоустойчивость | Failover при падении |
| **Read Scaling** | Масштабирование чтения | Распределение нагрузки |
| **Geo-distribution** | Низкая латентность | Реплики в разных регионах |
| **Data Protection** | Защита от потери | Копия в другом DC |

---

## Вопрос 19: Репликация через лидера (Leader-based)

### Архитектура

**Leader-based репликация** (она же Master-Slave, Primary-Replica):

```
┌─────────────────────────────────────────────────────────┐
│              LEADER-BASED РЕПЛИКАЦИЯ                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│                    ┌─────────┐                          │
│  Записи ──────────►│ LEADER  │                          │
│                    │(Master) │                          │
│                    └────┬────┘                          │
│                         │                               │
│            Replication Log (WAL)                        │
│                         │                               │
│         ┌───────────────┼───────────────┐               │
│         ▼               ▼               ▼               │
│    ┌─────────┐    ┌─────────┐    ┌─────────┐            │
│    │Follower1│    │Follower2│    │Follower3│            │
│    │(Replica)│    │(Replica)│    │(Replica)│            │
│    └─────────┘    └─────────┘    └─────────┘            │
│         ▲               ▲               ▲               │
│         └───────────────┴───────────────┘               │
│                    Чтения                               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Как это работает?

#### Шаг 1: Запись на Leader

```
Клиент                Leader                 Followers
   │                    │                        │
   │──── INSERT ───────►│                        │
   │                    │                        │
   │                    │ 1. Записать в WAL      │
   │                    │ 2. Применить изменение │
   │                    │                        │
```

#### Шаг 2: Репликация на Followers

```
Клиент                Leader                 Followers
   │                    │                        │
   │                    │──── WAL запись ───────►│
   │                    │                        │
   │                    │                   Применить
   │                    │                   изменение
   │                    │                        │
```

#### Шаг 3: Подтверждение (зависит от режима)

```
Синхронная репликация:
   │                    │                        │
   │                    │◄─── OK ────────────────│
   │◄─── OK ────────────│                        │
   │                    │                        │

Асинхронная репликация:
   │                    │                        │
   │◄─── OK ────────────│     (не ждём)          │
   │                    │                        │
```

### Синхронная vs Асинхронная репликация

#### Синхронная репликация

```
┌─────────────────────────────────────────────────────────┐
│                 СИНХРОННАЯ РЕПЛИКАЦИЯ                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Leader ждёт подтверждения от реплик ПЕРЕД ответом      │
│                                                         │
│  Клиент → Leader → Replicas → Leader → Клиент           │
│           │                     ▲                       │
│           └─────── ждём ────────┘                       │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Данные гарантированно на репликах                    │
│  • При падении Leader данные не потеряются              │
│                                                         │
│  ❌ Минусы:                                             │
│  • Медленнее (ждём сеть)                                │
│  • Одна медленная реплика тормозит всех                 │
│  • При недоступности реплики — запись блокируется       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### Асинхронная репликация

```
┌─────────────────────────────────────────────────────────┐
│                АСИНХРОННАЯ РЕПЛИКАЦИЯ                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Leader отвечает сразу, реплики догоняют потом          │
│                                                         │
│  Клиент → Leader → Клиент                               │
│              │                                          │
│              └──────► Replicas (позже)                  │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Быстрее (не ждём реплики)                            │
│  • Реплики могут отставать                              │
│  • Одна медленная реплика не влияет на запись           │
│                                                         │
│  ❌ Минусы:                                             │
│  • При падении Leader — потеря последних записей        │
│  • Чтение с реплики может вернуть устаревшие данные     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### Полусинхронная репликация (Semi-sync)

```
┌─────────────────────────────────────────────────────────┐
│              ПОЛУСИНХРОННАЯ РЕПЛИКАЦИЯ                  │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Ждём подтверждения хотя бы от ОДНОЙ реплики            │
│                                                         │
│  ┌────────┐         ┌─────────┐                         │
│  │ Leader │────────►│Replica 1│ ← Синхронная            │
│  │        │         └─────────┘   (ждём OK)             │
│  │        │         ┌─────────┐                         │
│  │        │────────►│Replica 2│ ← Асинхронная           │
│  └────────┘         └─────────┘   (не ждём)             │
│                                                         │
│  Компромисс: надёжность + скорость                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Чтение с реплик

```
┌─────────────────────────────────────────────────────────┐
│                  ЧТЕНИЕ С РЕПЛИК                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Паттерн: Read from Replica, Write to Leader            │
│                                                         │
│         ┌─────────┐                                     │
│  Write─►│ Leader  │                                     │
│         └────┬────┘                                     │
│              │                                          │
│         ┌────┴────┐                                     │
│         ▼         ▼                                     │
│    ┌─────────┐ ┌─────────┐                              │
│    │Replica 1│ │Replica 2│                              │
│    └────▲────┘ └────▲────┘                              │
│         │           │                                   │
│       Read        Read                                  │
│                                                         │
│  ⚠️ Проблема: Replica может отставать от Leader!        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Вопрос 20: Eventual Consistency и Replication Lag

### Что такое Eventual Consistency?

**Eventual Consistency** (согласованность в конечном счёте) — это гарантия, что:

> Если новых записей нет, то со временем ВСЕ реплики 
> вернут одинаковые данные.

```
Время ──────────────────────────────────────────────────►

Запись x=5
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ Leader:   x=5 ✓                                         │
│ Replica1: x=3 (старое) → x=5 ✓                          │
│ Replica2: x=3 (старое) → x=3 → x=5 ✓                    │
│ Replica3: x=3 (старое) → x=3 → x=3 → x=5 ✓              │
└─────────────────────────────────────────────────────────┘
                                    ▲
                                    │
                              Eventually
                              Consistent!
```

### Что такое Replication Lag?

**Replication Lag** — задержка между записью на Leader и появлением данных на Replica.

```
┌─────────────────────────────────────────────────────────┐
│                   REPLICATION LAG                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  T=0:  Клиент записал x=5 на Leader                     │
│  T=0:  Leader: x=5                                      │
│  T=0:  Replica: x=3 (старое)                            │
│                                                         │
│  T=50ms: Replica получила изменение                     │
│  T=50ms: Replica: x=5                                   │
│                                                         │
│  Replication Lag = 50ms                                 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Проблемы из-за Replication Lag

#### 1. Read Your Own Writes

```
┌─────────────────────────────────────────────────────────┐
│              READ YOUR OWN WRITES                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Проблема:                                              │
│  1. Пользователь обновил профиль (запись на Leader)     │
│  2. Страница перезагрузилась (чтение с Replica)         │
│  3. Видит СТАРЫЕ данные! 😱                             │
│                                                         │
│  ┌────────┐  write   ┌────────┐                         │
│  │ User   │─────────►│ Leader │  name="John"            │
│  └────────┘          └────────┘                         │
│      │                   │                              │
│      │                   ▼ (lag)                        │
│      │               ┌────────┐                         │
│      └──── read ────►│Replica │  name="Jon" (старое!)   │
│                      └────────┘                         │
│                                                         │
│  Решение:                                               │
│  • Читать свои записи с Leader                          │
│  • Помнить timestamp последней записи                   │
│  • Ждать, пока Replica догонит                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 2. Monotonic Reads

```
┌─────────────────────────────────────────────────────────┐
│                   MONOTONIC READS                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Проблема:                                              │
│  1. Пользователь читает x=5 с Replica1                  │
│  2. Следующий запрос идёт на Replica2 (отстаёт)         │
│  3. Видит x=3 — данные "откатились назад"! 😱           │
│                                                         │
│  ┌────────┐  read1   ┌──────────┐                       │
│  │ User   │─────────►│ Replica1 │  x=5 ✓                │
│  └────────┘          └──────────┘                       │
│      │                                                  │
│      │    read2      ┌──────────┐                       │
│      └──────────────►│ Replica2 │  x=3 ✗ (старее!)      │
│                      └──────────┘                       │
│                                                         │
│  Решение:                                               │
│  • Sticky sessions (всегда одна реплика)                │
│  • Читать с реплики не старше предыдущего чтения        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 3. Consistent Prefix Reads

```
┌─────────────────────────────────────────────────────────┐
│               CONSISTENT PREFIX READS                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Проблема: Нарушение причинно-следственной связи        │
│                                                         │
│  Порядок на Leader:                                     │
│  1. "Который час?" (Alice)                              │
│  2. "10:00" (Bob)                                       │
│                                                         │
│  Порядок на Replica (из-за лага):                       │
│  1. "10:00" (Bob)        ← Ответ раньше вопроса!        │
│  2. "Который час?" (Alice)                              │
│                                                         │
│  Решение:                                               │
│  • Партиционирование по ключу                           │
│  • Сохранение порядка для связанных записей             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Как мониторить Replication Lag?

```sql
-- PostgreSQL: проверка лага репликации
SELECT 
    client_addr,
    state,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn,
    pg_wal_lsn_diff(sent_lsn, replay_lsn) AS lag_bytes
FROM pg_stat_replication;

-- MySQL: проверка лага
SHOW SLAVE STATUS\G
-- Смотреть на Seconds_Behind_Master
```

---

## Вопрос 21: Способы репликации

### 1. Statement-based Replication

```
┌─────────────────────────────────────────────────────────┐
│              STATEMENT-BASED REPLICATION                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Что реплицируется: SQL-запросы                         │
│                                                         │
│  Leader выполняет:                                      │
│  INSERT INTO users VALUES (1, 'John', NOW());           │
│                                                         │
│  Replica получает тот же SQL и выполняет его            │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Компактно (только текст запроса)                     │
│  • Легко читать логи                                    │
│                                                         │
│  ❌ Минусы:                                             │
│  • NOW(), RANDOM() дают разные результаты!              │
│  • Триггеры могут работать по-разному                   │
│  • Порядок выполнения может отличаться                  │
│                                                         │
│  Используется: MySQL (старые версии), PostgreSQL        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2. Row-based Replication (Logical)

```
┌─────────────────────────────────────────────────────────┐
│               ROW-BASED REPLICATION                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Что реплицируется: Изменённые строки                   │
│                                                         │
│  Leader выполняет:                                      │
│  UPDATE users SET name='John' WHERE id=1;               │
│                                                         │
│  Replica получает:                                      │
│  {table: users, pk: 1, old: {name: 'Jon'},              │
│   new: {name: 'John'}}                                  │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Детерминировано (нет NOW(), RANDOM())                │
│  • Точное воспроизведение изменений                     │
│  • Можно использовать для CDC                           │
│                                                         │
│  ❌ Минусы:                                             │
│  • Больше данных при массовых UPDATE                    │
│  • UPDATE 1M строк = 1M записей в лог                   │
│                                                         │
│  Используется: MySQL (default), PostgreSQL logical      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 3. Write-Ahead Log (WAL) Shipping

```
┌─────────────────────────────────────────────────────────┐
│                  WAL SHIPPING                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Что реплицируется: Бинарный WAL (физический лог)       │
│                                                         │
│  ┌────────┐                     ┌─────────┐             │
│  │ Leader │ ──── WAL файлы ────►│ Replica │             │
│  └────────┘                     └─────────┘             │
│                                                         │
│  WAL содержит:                                          │
│  • Какие байты изменились                               │
│  • На каких страницах                                   │
│  • В каком порядке                                      │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Максимально точное копирование                       │
│  • Быстрое применение                                   │
│                                                         │
│  ❌ Минусы:                                             │
│  • Привязка к версии БД                                 │
│  • Нельзя реплицировать между разными БД                │
│  • Replica read-only                                    │
│                                                         │
│  Используется: PostgreSQL streaming replication         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 4. Trigger-based Replication

```
┌─────────────────────────────────────────────────────────┐
│              TRIGGER-BASED REPLICATION                  │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Как работает:                                          │
│  1. Триггер на каждую таблицу                           │
│  2. При изменении — запись в таблицу изменений          │
│  3. Внешний процесс читает и применяет на реплике       │
│                                                         │
│  CREATE TRIGGER log_changes                             │
│  AFTER INSERT OR UPDATE OR DELETE ON users              │
│  FOR EACH ROW EXECUTE FUNCTION log_change();            │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Гибкость (можно фильтровать)                         │
│  • Работает между разными БД                            │
│                                                         │
│  ❌ Минусы:                                             │
│  • Медленно                                             │
│  • Сложно поддерживать                                  │
│  • Overhead на каждую операцию                          │
│                                                         │
│  Используется: Bucardo, Londiste, custom solutions      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Сравнение способов

| Способ | Что реплицируется | Точность | Производительность |
|--------|-------------------|----------|-------------------|
| Statement | SQL запросы | Низкая | Высокая |
| Row-based | Изменённые строки | Высокая | Средняя |
| WAL | Бинарный лог | Максимальная | Высокая |
| Trigger | Через триггеры | Высокая | Низкая |

---

## Вопрос 22: Multi-Master репликация

### Что такое Multi-Master?

**Multi-Master** (Multi-Leader) — когда НЕСКОЛЬКО узлов принимают записи.

```
┌─────────────────────────────────────────────────────────┐
│                    MULTI-MASTER                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────┐         ┌─────────┐         ┌─────────┐    │
│  │ Master1 │◄───────►│ Master2 │◄───────►│ Master3 │    │
│  │ (NYC)   │         │ (London)│         │ (Tokyo) │    │
│  └────▲────┘         └────▲────┘         └────▲────┘    │
│       │                   │                   │         │
│    Записи              Записи              Записи       │
│    из США             из Европы           из Азии       │
│                                                         │
│  Каждый Master реплицирует изменения на другие          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Зачем нужен Multi-Master?

#### 1. Географическое распределение

```
Single-Master:                    Multi-Master:
                                  
Клиент в Токио                    Клиент в Токио
     │                                 │
     │ 200ms                           │ 5ms
     ▼                                 ▼
┌─────────┐                       ┌─────────┐
│ Master  │                       │ Master  │
│ (NYC)   │                       │ (Tokyo) │
└─────────┘                       └─────────┘

Записи идут через океан!          Записи локально!
```

#### 2. Высокая доступность при записи

```
Single-Master:                    Multi-Master:
                                  
Master упал                       Master1 упал
     │                                 │
     ▼                            ┌────┴────┐
Записи невозможны!                ▼         ▼
(пока failover)                Master2   Master3
                               Записи продолжаются!
```

### Главная проблема: Конфликты

```
┌─────────────────────────────────────────────────────────┐
│                      КОНФЛИКТЫ                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Сценарий:                                              │
│  1. User1 в NYC меняет title на "Hello"                 │
│  2. User2 в Tokyo меняет title на "Привет"              │
│  3. Оба изменения происходят ОДНОВРЕМЕННО               │
│                                                         │
│  ┌─────────┐                         ┌─────────┐        │
│  │ Master1 │   title="Hello"         │ Master2 │        │
│  │  (NYC)  │◄────────────────────────│ (Tokyo) │        │
│  │         │────────────────────────►│         │        │
│  └─────────┘   title="Привет"        └─────────┘        │
│                                                         │
│  Вопрос: Какое значение правильное?                     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Стратегии разрешения конфликтов

#### 1. Last Write Wins (LWW)

```
┌─────────────────────────────────────────────────────────┐
│                   LAST WRITE WINS                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Правило: Запись с бОльшим timestamp побеждает          │
│                                                         │
│  Master1: title="Hello"    (timestamp: 100)             │
│  Master2: title="Привет"   (timestamp: 101)             │
│                                                         │
│  Результат: title="Привет" (101 > 100)                  │
│                                                         │
│  ⚠️ Проблемы:                                           │
│  • Потеря данных (Hello просто исчезает)                │
│  • Часы на серверах могут расходиться                   │
│                                                         │
│  Используется: Cassandra, DynamoDB                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 2. Merge (CRDT)

```
┌─────────────────────────────────────────────────────────┐
│              CONFLICT-FREE REPLICATED DATA TYPES        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Идея: Структуры данных, которые можно мержить          │
│        автоматически без конфликтов                     │
│                                                         │
│  Примеры CRDT:                                          │
│                                                         │
│  G-Counter (только увеличение):                         │
│  Master1: count=5                                       │
│  Master2: count=3                                       │
│  Merge: count=8 (5+3)                                   │
│                                                         │
│  G-Set (только добавление):                             │
│  Master1: {A, B}                                        │
│  Master2: {B, C}                                        │
│  Merge: {A, B, C}                                       │
│                                                         │
│  LWW-Register:                                          │
│  Как LWW, но для отдельных полей                        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 3. Custom Resolution

```
┌─────────────────────────────────────────────────────────┐
│                  CUSTOM RESOLUTION                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Идея: Приложение само решает, как разрешить конфликт   │
│                                                         │
│  Примеры:                                               │
│                                                         │
│  Корзина покупок:                                       │
│  Master1: cart=[A, B]                                   │
│  Master2: cart=[A, C]                                   │
│  Merge: cart=[A, B, C] (объединить)                     │
│                                                         │
│  Редактирование документа:                              │
│  Master1: text="Hello world"                            │
│  Master2: text="Hello there"                            │
│  Merge: Показать обе версии пользователю                │
│         (как в Google Docs)                             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Топологии Multi-Master

```
1. All-to-All (каждый с каждым):

   ┌───┐     ┌───┐
   │ 1 │◄───►│ 2 │
   └───┘     └───┘
     ▲  \   /  ▲
     │   \ /   │
     │    X    │
     │   / \   │
     ▼  /   \  ▼
   ┌───┐     ┌───┐
   │ 3 │◄───►│ 4 │
   └───┘     └───┘

2. Circular (кольцо):

   ┌───┐ ──► ┌───┐
   │ 1 │     │ 2 │
   └───┘     └───┘
     ▲         │
     │         ▼
   ┌───┐ ◄── ┌───┐
   │ 4 │     │ 3 │
   └───┘     └───┘

3. Star (звезда):

         ┌───┐
         │ 1 │
         └───┘
        /  │  \
       /   │   \
      ▼    ▼    ▼
   ┌───┐┌───┐┌───┐
   │ 2 ││ 3 ││ 4 │
   └───┘└───┘└───┘
```

### Когда использовать Multi-Master?

```
┌─────────────────────────────────────────────────────────┐
│               КОГДА ИСПОЛЬЗОВАТЬ                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ✅ Используй Multi-Master когда:                       │
│  • Географически распределённые пользователи            │
│  • Нужна запись с низкой латентностью везде             │
│  • Можешь разрешать конфликты                           │
│  • Данные можно партиционировать                        │
│                                                         │
│  ❌ НЕ используй Multi-Master когда:                    │
│  • Строгая консистентность критична                     │
│  • Сложно разрешать конфликты                           │
│  • Можно обойтись Single-Master + реплики               │
│                                                         │
│  Примеры Multi-Master систем:                           │
│  • CockroachDB                                          │
│  • Cassandra                                            │
│  • Google Spanner                                       │
│  • Galera Cluster (MySQL)                               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Ключевые термины

| Термин | Определение |
|--------|-------------|
| **Репликация** | Копирование данных на несколько узлов |
| **Leader (Master)** | Узел, принимающий записи |
| **Follower (Replica)** | Узел, копирующий данные с Leader |
| **Failover** | Переключение на реплику при падении Master |
| **Replication Lag** | Задержка между Leader и Replica |
| **Eventual Consistency** | Данные станут согласованными со временем |
| **WAL** | Write-Ahead Log — журнал изменений |
| **Multi-Master** | Несколько узлов принимают записи |
| **LWW** | Last Write Wins — стратегия разрешения конфликтов |
| **CRDT** | Структуры данных без конфликтов при слиянии |

---

## Что запомнить

1. **Репликация нужна для:** HA, масштабирования чтения, geo-distribution
2. **Синхронная = надёжно, но медленно; Асинхронная = быстро, но рискованно**
3. **Replication Lag вызывает проблемы:** read-your-writes, monotonic reads
4. **WAL shipping — самый надёжный способ репликации**
5. **Multi-Master = конфликты, нужна стратегия разрешения**

---

*Следующий файл: [05. Партиционирование](05_partitioning.md)*


