# 03. Базы данных — основы

> **Сложность:** ⭐⭐ Средний уровень
> **Вопросы из списка:** 13, 14, 15, 16, 17

---

## Вопрос 13: Какие бывают базы данных?

### Классификация баз данных

```
                        БАЗЫ ДАННЫХ
                             │
         ┌───────────────────┼───────────────────┐
         ▼                   ▼                   ▼
    РЕЛЯЦИОННЫЕ          NoSQL              СПЕЦИАЛЬНЫЕ
    (SQL)                                   
         │                   │                   │
    ┌────┴────┐    ┌────────┼────────┐    ┌────┴────┐
    │         │    │        │        │    │         │
PostgreSQL  MySQL  Key-Value Document  Graph  TimeSeries
Oracle     MariaDB Redis    MongoDB   Neo4j  InfluxDB
SQLite            Memcached Couchbase        Prometheus
```

### 1. Реляционные базы данных (SQL)

**Что это:** Данные хранятся в таблицах со строгой схемой.

```sql
-- Пример: таблица пользователей
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Связь между таблицами
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    amount DECIMAL(10, 2)
);
```

**Характеристики:**
| Плюсы | Минусы |
|-------|--------|
| ACID транзакции | Сложно масштабировать горизонтально |
| Строгая схема | Схема негибкая |
| Мощный SQL | JOIN-ы могут быть медленными |
| Зрелые инструменты | Не подходит для всех задач |

**Когда использовать:**
- Финансовые данные (нужен ACID)
- Сложные связи между данными
- Отчётность и аналитика

**Примеры:** PostgreSQL, MySQL, Oracle, SQLite

### 2. Key-Value базы данных

**Что это:** Простейшая модель — ключ и значение.

```
┌─────────────────────────────────────┐
│           KEY-VALUE                 │
├─────────────────────────────────────┤
│  "user:123"     → "{name: 'John'}" │
│  "session:abc"  → "user_id=123"    │
│  "cache:page1"  → "<html>..."      │
└─────────────────────────────────────┘
```

**Характеристики:**
| Плюсы | Минусы |
|-------|--------|
| Очень быстрые (O(1)) | Нет сложных запросов |
| Легко масштабировать | Нет связей между данными |
| Простая модель | Только get/set/delete |

**Когда использовать:**
- Кэширование
- Сессии пользователей
- Очереди сообщений

**Примеры:** Redis, Memcached, etcd

### 3. Document базы данных

**Что это:** Хранят документы (обычно JSON/BSON).

```json
// Пример документа в MongoDB
{
  "_id": "user123",
  "name": "John",
  "email": "john@example.com",
  "addresses": [
    {"city": "Moscow", "zip": "123456"},
    {"city": "SPb", "zip": "654321"}
  ],
  "orders": [
    {"id": 1, "amount": 100},
    {"id": 2, "amount": 200}
  ]
}
```

**Характеристики:**
| Плюсы | Минусы |
|-------|--------|
| Гибкая схема | Нет JOIN-ов (денормализация) |
| Хранит вложенные данные | Дублирование данных |
| Легко масштабировать | Сложнее поддерживать консистентность |

**Когда использовать:**
- Контент (статьи, товары)
- Каталоги с разной структурой
- Прототипирование (схема меняется)

**Примеры:** MongoDB, CouchDB, Elasticsearch

### 4. Column-Family (Wide Column)

**Что это:** Данные группируются по колонкам, а не по строкам.

```
┌─────────────────────────────────────────────────────┐
│                 COLUMN FAMILY                       │
├─────────────────────────────────────────────────────┤
│ Row Key │ Column Family: profile │ CF: activity    │
├─────────┼────────────────────────┼─────────────────┤
│ user1   │ name=John, age=25      │ logins=100      │
│ user2   │ name=Jane              │ logins=50,      │
│         │                        │ purchases=10    │
└─────────┴────────────────────────┴─────────────────┘
```

**Характеристики:**
| Плюсы | Минусы |
|-------|--------|
| Отлично для аналитики | Сложная модель данных |
| Масштабируется на петабайты | Нет ACID |
| Быстрая запись | Сложные запросы медленные |

**Когда использовать:**
- Big Data аналитика
- Временные ряды (IoT, метрики)
- Логи в больших объёмах

**Примеры:** Cassandra, HBase, ScyllaDB

### 5. Graph базы данных

**Что это:** Данные — это узлы и связи между ними.

```
        ┌─────────┐
        │  John   │
        │ (User)  │
        └────┬────┘
             │ FOLLOWS
             ▼
        ┌─────────┐      LIKES      ┌─────────┐
        │  Jane   │────────────────►│  Post1  │
        │ (User)  │                 │ (Post)  │
        └────┬────┘                 └─────────┘
             │ WORKS_AT
             ▼
        ┌─────────┐
        │ Company │
        │  (Org)  │
        └─────────┘
```

**Характеристики:**
| Плюсы | Минусы |
|-------|--------|
| Отличны для связей | Не для простых данных |
| Быстрый обход графа | Сложнее масштабировать |
| Интуитивная модель | Специфичный язык запросов |

**Когда использовать:**
- Социальные сети (друзья друзей)
- Рекомендации
- Fraud detection
- Knowledge graphs

**Примеры:** Neo4j, Amazon Neptune, ArangoDB

### 6. Time Series базы данных

**Что это:** Оптимизированы для данных с временными метками.

```
┌─────────────────────────────────────────────────────┐
│                 TIME SERIES                         │
├─────────────────────────────────────────────────────┤
│ timestamp           │ metric    │ value │ tags     │
├─────────────────────┼───────────┼───────┼──────────┤
│ 2024-01-01 00:00:00 │ cpu_usage │ 45.2  │ host=s1  │
│ 2024-01-01 00:00:01 │ cpu_usage │ 46.1  │ host=s1  │
│ 2024-01-01 00:00:02 │ cpu_usage │ 44.8  │ host=s1  │
└─────────────────────┴───────────┴───────┴──────────┘
```

**Характеристики:**
| Плюсы | Минусы |
|-------|--------|
| Оптимизированы для временных данных | Только для временных рядов |
| Сжатие данных | Ограниченные запросы |
| Быстрая агрегация | Не для транзакций |

**Когда использовать:**
- Мониторинг и метрики
- IoT данные
- Финансовые котировки

**Примеры:** InfluxDB, Prometheus, TimescaleDB, ClickHouse

### Сводная таблица

| Тип | Модель | Масштабирование | ACID | Пример использования |
|-----|--------|-----------------|------|---------------------|
| SQL | Таблицы | Вертикальное | ✅ | Финансы, ERP |
| Key-Value | Ключ-значение | Горизонтальное | ❌ | Кэш, сессии |
| Document | JSON документы | Горизонтальное | Частично | Каталоги, CMS |
| Column | Колонки | Горизонтальное | ❌ | Big Data, логи |
| Graph | Узлы и связи | Ограниченное | Частично | Соцсети |
| TimeSeries | Временные ряды | Горизонтальное | ❌ | Мониторинг |

---

## Вопрос 14: Какие популярные способы обращения к данным?

### 1. По первичному ключу (Primary Key Lookup)

```sql
-- Самый быстрый способ — O(1) или O(log n)
SELECT * FROM users WHERE id = 123;
```

**Когда использовать:** Когда знаешь точный ID.

### 2. По вторичному индексу (Secondary Index)

```sql
-- Быстро, если есть индекс
SELECT * FROM users WHERE email = 'john@example.com';

-- Создание индекса
CREATE INDEX idx_users_email ON users(email);
```

**Когда использовать:** Частые запросы по определённому полю.

### 3. Полное сканирование (Full Table Scan)

```sql
-- Медленно! Читает ВСЮ таблицу
SELECT * FROM users WHERE name LIKE '%john%';
```

**Когда использовать:** Аналитика, редкие запросы.

### 4. Range Scan (диапазон)

```sql
-- Использует индекс для диапазона
SELECT * FROM orders 
WHERE created_at BETWEEN '2024-01-01' AND '2024-01-31';
```

**Когда использовать:** Временные диапазоны, числовые интервалы.

### 5. JOIN (соединение таблиц)

```sql
-- Объединение данных из нескольких таблиц
SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.created_at > '2024-01-01';
```

**Типы JOIN:**
```
INNER JOIN  — только совпадающие записи
LEFT JOIN   — все из левой + совпадающие из правой
RIGHT JOIN  — все из правой + совпадающие из левой
FULL JOIN   — все записи из обеих таблиц
```

### 6. Агрегация (Aggregation)

```sql
-- Подсчёт, суммы, средние
SELECT 
    DATE(created_at) as day,
    COUNT(*) as orders_count,
    SUM(amount) as total_amount
FROM orders
GROUP BY DATE(created_at);
```

### Паттерны доступа к данным

```
┌─────────────────────────────────────────────────────────┐
│              ПАТТЕРНЫ ДОСТУПА К ДАННЫМ                  │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  OLTP (Online Transaction Processing)                   │
│  ─────────────────────────────────────                  │
│  • Много мелких операций                                │
│  • Чтение/запись по ключу                               │
│  • Низкая латентность важна                             │
│  • Пример: интернет-магазин                             │
│                                                         │
│  OLAP (Online Analytical Processing)                    │
│  ─────────────────────────────────────                  │
│  • Мало больших запросов                                │
│  • Агрегации, GROUP BY                                  │
│  • Пропускная способность важна                         │
│  • Пример: отчёты, дашборды                             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Вопрос 15: Зачем базам данных индексы?

### Проблема без индексов

```
Таблица users: 1,000,000 записей

Запрос: SELECT * FROM users WHERE email = 'john@example.com'

Без индекса:
┌────────────────────────────────────────────┐
│ Читаем ВСЕ 1,000,000 записей               │
│ Сравниваем каждую с 'john@example.com'     │
│ Время: O(n) = очень долго!                 │
└────────────────────────────────────────────┘
```

### Решение: Индекс

```
С индексом:
┌────────────────────────────────────────────┐
│ Ищем в индексе (как в словаре)             │
│ Находим указатель на строку                │
│ Читаем только 1 строку                     │
│ Время: O(log n) = быстро!                  │
└────────────────────────────────────────────┘
```

### Популярные алгоритмы индексов

#### 1. B-Tree (Balanced Tree)

**Самый популярный.** Используется по умолчанию в PostgreSQL, MySQL.

```
                    [M]
                   /   \
              [D,H]     [R,X]
             /  |  \    /  |  \
          [A,C][E,G][I,K][N,P][S,V][Y,Z]
          
Поиск "G": M → H → G  (3 шага вместо перебора)
```

**Характеристики:**
- Поиск: O(log n)
- Вставка: O(log n)
- Удаление: O(log n)
- Поддерживает диапазоны: `WHERE x > 10 AND x < 20`

**Когда использовать:** Почти всегда (по умолчанию).

#### 2. Hash Index

```
hash("john@example.com") = 42
                           │
                           ▼
┌─────┬─────┬─────┬─────┬─────┬─────┐
│  0  │  1  │ ... │ 42  │ ... │ 99  │
└─────┴─────┴─────┴──┬──┴─────┴─────┘
                     │
                     ▼
              [указатель на строку]
```

**Характеристики:**
- Поиск: O(1) — мгновенно!
- НЕ поддерживает диапазоны
- Только точное совпадение

**Когда использовать:** Только `WHERE x = value`, не для диапазонов.

#### 3. GiST (Generalized Search Tree)

**Для геоданных и полнотекстового поиска.**

```sql
-- Поиск ближайших точек
SELECT * FROM places 
WHERE location <-> point(55.75, 37.62) < 1000;

-- Полнотекстовый поиск
SELECT * FROM articles 
WHERE to_tsvector(content) @@ to_tsquery('postgres & index');
```

#### 4. GIN (Generalized Inverted Index)

**Для массивов и JSON.**

```sql
-- Поиск в массиве
SELECT * FROM products 
WHERE tags @> ARRAY['electronics', 'sale'];

-- Поиск в JSON
SELECT * FROM events 
WHERE data @> '{"type": "click"}';
```

### Составные индексы

```sql
-- Индекс по нескольким колонкам
CREATE INDEX idx_orders_user_date 
ON orders(user_id, created_at);

-- Работает для:
WHERE user_id = 123                      ✅
WHERE user_id = 123 AND created_at > X   ✅
WHERE created_at > X                     ❌ (не использует индекс!)
```

**Правило:** Порядок колонок важен! Индекс работает слева направо.

### Цена индексов

```
┌─────────────────────────────────────────────────────────┐
│                  TRADE-OFFS ИНДЕКСОВ                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ПЛЮСЫ:                      МИНУСЫ:                    │
│  • Быстрое чтение            • Медленная запись         │
│  • Быстрый поиск             • Занимает место на диске  │
│                              • Нужно обновлять при      │
│                                INSERT/UPDATE/DELETE     │
│                                                         │
│  Правило: Не создавай индексы "на всякий случай"!       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Вопрос 16: Локальность данных. Колоночное vs строковое хранение

### Локальность данных (Data Locality)

**Принцип:** Данные, которые читаются вместе, должны храниться рядом.

```
Диск читает данные БЛОКАМИ (например, 4KB)

Хорошо: Нужные данные в одном блоке
┌────────────────────────────────────┐
│ [user1] [user2] [user3] [user4]    │  ← 1 чтение
└────────────────────────────────────┘

Плохо: Нужные данные разбросаны
┌──────────┐  ┌──────────┐  ┌──────────┐
│ [user1]  │  │ [user2]  │  │ [user3]  │  ← 3 чтения!
└──────────┘  └──────────┘  └──────────┘
```

### Строковое хранение (Row-oriented)

**Как хранится:** Все колонки одной строки рядом.

```
┌─────────────────────────────────────────────────────────┐
│                   ROW STORAGE                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ Блок 1: [id=1, name="John", age=25, city="Moscow"]     │
│ Блок 2: [id=2, name="Jane", age=30, city="SPb"]        │
│ Блок 3: [id=3, name="Bob", age=22, city="Moscow"]      │
│                                                         │
└─────────────────────────────────────────────────────────┘

Запрос: SELECT * FROM users WHERE id = 1
        → Читаем 1 блок, получаем ВСЕ данные пользователя ✅

Запрос: SELECT AVG(age) FROM users
        → Читаем ВСЕ блоки, но нужен только age ❌
```

**Когда использовать:**
- OLTP (транзакции)
- Чтение полных записей
- INSERT/UPDATE отдельных строк

**Примеры:** PostgreSQL, MySQL, Oracle

### Колоночное хранение (Column-oriented)

**Как хранится:** Все значения одной колонки рядом.

```
┌─────────────────────────────────────────────────────────┐
│                   COLUMN STORAGE                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ Блок id:   [1, 2, 3, 4, 5, 6, 7, 8, ...]               │
│ Блок name: ["John", "Jane", "Bob", ...]                │
│ Блок age:  [25, 30, 22, 28, 35, ...]                   │
│ Блок city: ["Moscow", "SPb", "Moscow", ...]            │
│                                                         │
└─────────────────────────────────────────────────────────┘

Запрос: SELECT AVG(age) FROM users
        → Читаем ТОЛЬКО блок age ✅

Запрос: SELECT * FROM users WHERE id = 1
        → Читаем ВСЕ блоки, собираем строку ❌
```

**Когда использовать:**
- OLAP (аналитика)
- Агрегации (SUM, AVG, COUNT)
- Чтение нескольких колонок из миллионов строк

**Примеры:** ClickHouse, Vertica, Amazon Redshift, Parquet

### Сравнение

| Характеристика | Row Storage | Column Storage |
|----------------|-------------|----------------|
| Чтение строки целиком | ✅ Быстро | ❌ Медленно |
| Агрегации | ❌ Медленно | ✅ Быстро |
| INSERT одной строки | ✅ Быстро | ❌ Медленно |
| Сжатие | Среднее | Отличное (одинаковые типы) |
| OLTP | ✅ Подходит | ❌ Не подходит |
| OLAP | ❌ Не подходит | ✅ Подходит |

### Пример: Почему колоночное хранение сжимается лучше

```
Row storage (city):
"Moscow", "SPb", "Moscow", "Moscow", "SPb", "Moscow"
→ Разные значения рядом, сжатие слабое

Column storage (city):
"Moscow", "Moscow", "Moscow", "Moscow", "SPb", "SPb"
→ Одинаковые значения рядом, RLE сжатие: "Moscow"×4, "SPb"×2
```

---

## Вопрос 17: Что такое ACID и BASE?

### ACID — гарантии транзакций

**ACID** — это набор свойств, гарантирующих надёжность транзакций.

```
┌─────────────────────────────────────────────────────────┐
│                        ACID                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  A — Atomicity (Атомарность)                            │
│      Транзакция либо выполняется полностью,             │
│      либо не выполняется вообще.                        │
│                                                         │
│  C — Consistency (Согласованность)                      │
│      БД переходит из одного валидного состояния         │
│      в другое валидное состояние.                       │
│                                                         │
│  I — Isolation (Изоляция)                               │
│      Параллельные транзакции не мешают друг другу.      │
│                                                         │
│  D — Durability (Долговечность)                         │
│      После коммита данные сохранены навсегда.           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### Atomicity (Атомарность)

```sql
-- Перевод денег: либо оба действия, либо ни одного
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- Если что-то пошло не так:
ROLLBACK;  -- Всё откатывается
```

#### Consistency (Согласованность)

```sql
-- Ограничения (constraints) проверяются
ALTER TABLE accounts ADD CONSTRAINT positive_balance 
    CHECK (balance >= 0);

-- Транзакция, нарушающая constraint, откатится
UPDATE accounts SET balance = -100 WHERE id = 1;
-- ERROR: new row violates check constraint
```

#### Isolation (Изоляция)

**Уровни изоляции:**

| Уровень | Dirty Read | Non-repeatable Read | Phantom Read |
|---------|------------|---------------------|--------------|
| Read Uncommitted | ✅ Возможно | ✅ Возможно | ✅ Возможно |
| Read Committed | ❌ | ✅ Возможно | ✅ Возможно |
| Repeatable Read | ❌ | ❌ | ✅ Возможно |
| Serializable | ❌ | ❌ | ❌ |

```sql
-- Установка уровня изоляции
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

**Объяснение аномалий:**

```
┌─────────────────────────────────────────────────────────┐
│                    АНОМАЛИИ ИЗОЛЯЦИИ                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. DIRTY READ (грязное чтение)                         │
│     ─────────────────────────────                       │
│     Tx1: UPDATE balance = 0     (не закоммичено)        │
│     Tx2: SELECT balance → 0     (видит незакоммиченное) │
│     Tx1: ROLLBACK               (откат!)                │
│     Tx2 видел данные, которых никогда не было!          │
│                                                         │
│  2. NON-REPEATABLE READ (неповторяемое чтение)          │
│     ──────────────────────────────────────────          │
│     Tx1: SELECT balance → 100                           │
│     Tx2: UPDATE balance = 50; COMMIT;                   │
│     Tx1: SELECT balance → 50   (изменилось!)            │
│     Два SELECT в одной транзакции дали разный результат │
│                                                         │
│  3. PHANTOM READ (фантомное чтение)                     │
│     ─────────────────────────────────                   │
│     Tx1: SELECT * WHERE age > 18 → 10 строк             │
│     Tx2: INSERT (age=25); COMMIT;                       │
│     Tx1: SELECT * WHERE age > 18 → 11 строк (фантом!)   │
│     Появилась строка, которой не было                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Когда какой уровень использовать:**

```
┌─────────────────────────────────────────────────────────┐
│              ВЫБОР УРОВНЯ ИЗОЛЯЦИИ                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  READ COMMITTED (PostgreSQL default)                    │
│  • Большинство приложений                               │
│  • Хороший баланс скорость/безопасность                 │
│                                                         │
│  REPEATABLE READ (MySQL default)                        │
│  • Отчёты, которые читают данные несколько раз          │
│  • Когда важна консистентность внутри транзакции        │
│                                                         │
│  SERIALIZABLE                                           │
│  • Финансовые операции                                  │
│  • Когда нужна 100% корректность                        │
│  • ⚠️ Самый медленный, возможны deadlocks               │
│                                                         │
│  READ UNCOMMITTED                                       │
│  • Почти никогда не используется                        │
│  • Разве что для приблизительной аналитики              │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### Durability (Долговечность)

```
После COMMIT:
┌─────────────────────────────────────────────────────────┐
│ 1. Данные записаны в WAL (Write-Ahead Log)             │
│ 2. WAL сброшен на диск (fsync)                         │
│ 3. Даже при сбое питания данные восстановятся          │
└─────────────────────────────────────────────────────────┘
```

### BASE — альтернатива ACID

**BASE** — это подход для распределённых систем, где ACID слишком дорог.

```
┌─────────────────────────────────────────────────────────┐
│                        BASE                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  BA — Basically Available (Базовая доступность)         │
│       Система всегда отвечает (может с устаревшими      │
│       данными).                                         │
│                                                         │
│  S — Soft State (Мягкое состояние)                      │
│      Состояние системы может меняться со временем       │
│      даже без новых записей (из-за репликации).         │
│                                                         │
│  E — Eventual Consistency (Согласованность в итоге)     │
│      Данные станут согласованными, но не сразу.         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### ACID vs BASE

| Характеристика | ACID | BASE |
|----------------|------|------|
| Консистентность | Строгая | Eventual |
| Доступность | Может быть недоступна | Всегда доступна |
| Масштабирование | Сложное | Простое |
| Скорость | Медленнее | Быстрее |
| Применение | Банки, финансы | Соцсети, e-commerce |

### Примеры

```
ACID системы:
├── PostgreSQL
├── MySQL (InnoDB)
├── Oracle
└── SQL Server

BASE системы:
├── Cassandra
├── DynamoDB
├── MongoDB (по умолчанию)
└── Redis
```

### Когда что использовать?

```
┌─────────────────────────────────────────────────────────┐
│                   ВЫБОР: ACID vs BASE                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Используй ACID когда:                                  │
│  • Деньги, финансы                                      │
│  • Нельзя потерять данные                               │
│  • Важна строгая консистентность                        │
│                                                         │
│  Используй BASE когда:                                  │
│  • Высокая нагрузка                                     │
│  • Можно показать устаревшие данные                     │
│  • Важна доступность 24/7                               │
│  • Данные можно восстановить                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Ключевые термины

| Термин | Определение |
|--------|-------------|
| **OLTP** | Online Transaction Processing — много мелких операций |
| **OLAP** | Online Analytical Processing — аналитические запросы |
| **B-Tree** | Сбалансированное дерево для индексов |
| **Hash Index** | Индекс на основе хеш-функции |
| **Row Storage** | Строковое хранение (PostgreSQL) |
| **Column Storage** | Колоночное хранение (ClickHouse) |
| **ACID** | Atomicity, Consistency, Isolation, Durability |
| **BASE** | Basically Available, Soft state, Eventual consistency |

---

## Что запомнить

1. **SQL для транзакций, NoSQL для масштабирования**
2. **Индексы ускоряют чтение, замедляют запись**
3. **B-Tree — универсальный, Hash — только для точного поиска**
4. **Row storage для OLTP, Column storage для OLAP**
5. **ACID — надёжно, BASE — масштабируемо**

---

*Следующий файл: [04. Репликация](04_replication.md)*

