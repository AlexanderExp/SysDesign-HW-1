# 14. Очереди сообщений и асинхронность

> **Сложность:** ⭐⭐⭐ Продвинутый уровень
> **Дополнительная тема** — фундамент распределённых систем

---

## Зачем нужны очереди сообщений?

```
┌─────────────────────────────────────────────────────────┐
│            ЗАЧЕМ НУЖНЫ ОЧЕРЕДИ СООБЩЕНИЙ                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Проблема 1: Синхронные вызовы блокируют                │
│                                                         │
│  ❌ Синхронно:                                          │
│  User ──► API ──► Email Service ──► SMTP (5 сек!)       │
│                                                         │
│  Пользователь ждёт 5 секунд!                            │
│                                                         │
│  ✅ Асинхронно:                                         │
│  User ──► API ──► Queue ──► OK (50ms)                   │
│                    │                                    │
│                    └──► Email Worker ──► SMTP           │
│                                                         │
│  Пользователь получает ответ сразу!                     │
│                                                         │
│  Проблема 2: Пиковые нагрузки                           │
│                                                         │
│  ❌ Без очереди:                                        │
│  1000 RPS ──► Service (capacity 100) ──► CRASH!         │
│                                                         │
│  ✅ С очередью:                                         │
│  1000 RPS ──► Queue ──► Service (100 RPS) ──► OK        │
│              (буфер)                                    │
│                                                         │
│  Очередь сглаживает пики!                               │
│                                                         │
│  Проблема 3: Связанность сервисов                       │
│                                                         │
│  ❌ Tight coupling:                                     │
│  Order Service ──► Inventory ──► Shipping ──► Email     │
│                                                         │
│  Если Shipping упал — всё сломано!                      │
│                                                         │
│  ✅ Loose coupling:                                     │
│  Order Service ──► Queue                                │
│                      │                                  │
│                      ├──► Inventory                     │
│                      ├──► Shipping                      │
│                      └──► Email                         │
│                                                         │
│  Сервисы независимы!                                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Основные понятия

```
┌─────────────────────────────────────────────────────────┐
│                 ОСНОВНЫЕ ПОНЯТИЯ                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌──────────┐     ┌─────────────┐     ┌──────────┐      │
│  │ Producer │────►│    Queue    │────►│ Consumer │      │
│  │(отправит.)│     │  (очередь)  │     │(получат.)│      │
│  └──────────┘     └─────────────┘     └──────────┘      │
│                                                         │
│  Producer (Publisher): Отправляет сообщения             │
│  Queue (Topic): Хранит сообщения                        │
│  Consumer (Subscriber): Получает и обрабатывает         │
│  Message: Единица данных                                │
│  Broker: Сервер очередей (Kafka, RabbitMQ)              │
│                                                         │
│  Модели доставки:                                       │
│                                                         │
│  1. POINT-TO-POINT (Queue)                              │
│     Одно сообщение — один получатель                    │
│                                                         │
│     Producer ──► Queue ──► Consumer 1 (получил)         │
│                       └──► Consumer 2 (не получил)      │
│                                                         │
│  2. PUBLISH-SUBSCRIBE (Topic)                           │
│     Одно сообщение — все подписчики                     │
│                                                         │
│     Producer ──► Topic ──► Consumer 1 (получил)         │
│                       └──► Consumer 2 (получил)         │
│                       └──► Consumer 3 (получил)         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Гарантии доставки

```
┌─────────────────────────────────────────────────────────┐
│                 ГАРАНТИИ ДОСТАВКИ                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. AT-MOST-ONCE (не более одного раза)                 │
│     ─────────────────────────────────                   │
│     • Fire and forget                                   │
│     • Сообщение может потеряться                        │
│     • Самая быстрая, но ненадёжная                      │
│                                                         │
│     Producer ──► Broker                                 │
│                   │                                     │
│                   ✗ (потерялось)                        │
│                                                         │
│     Когда использовать: Метрики, логи (не критично)     │
│                                                         │
│  2. AT-LEAST-ONCE (хотя бы один раз)                    │
│     ─────────────────────────────────                   │
│     • Сообщение доставляется, но может дублироваться    │
│     • Consumer должен быть идемпотентным!               │
│                                                         │
│     Producer ──► Broker ──► Consumer                    │
│                         ──► Consumer (дубль!)           │
│                                                         │
│     Когда использовать: Большинство случаев             │
│                                                         │
│  3. EXACTLY-ONCE (ровно один раз)                       │
│     ────────────────────────────                        │
│     • Сообщение доставляется ровно один раз             │
│     • Самая сложная и дорогая                           │
│     • Требует транзакций                                │
│                                                         │
│     Когда использовать: Финансы, критичные данные       │
│                                                         │
│  ⚠️ На практике: AT-LEAST-ONCE + идемпотентность        │
│     = надёжно и просто                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Популярные системы

### RabbitMQ

```
┌─────────────────────────────────────────────────────────┐
│                     RABBITMQ                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Тип: Message Broker (брокер сообщений)                 │
│  Протокол: AMQP                                         │
│                                                         │
│  Архитектура:                                           │
│                                                         │
│  Producer ──► Exchange ──► Queue ──► Consumer           │
│                  │                                      │
│                  │ (routing)                            │
│                  │                                      │
│              ┌───┴───┐                                  │
│              ▼       ▼                                  │
│           Queue 1  Queue 2                              │
│                                                         │
│  Exchange Types:                                        │
│  • Direct: по routing key                               │
│  • Fanout: всем очередям                                │
│  • Topic: по паттерну (*.error, order.#)                │
│  • Headers: по заголовкам                               │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Гибкая маршрутизация                                 │
│  • Подтверждения (ack/nack)                             │
│  • Dead Letter Queue                                    │
│  • Простота                                             │
│                                                         │
│  ❌ Минусы:                                             │
│  • Не для больших объёмов                               │
│  • Сообщения удаляются после чтения                     │
│                                                         │
│  Когда использовать:                                    │
│  • Задачи в фоне                                        │
│  • RPC                                                  │
│  • Небольшие/средние нагрузки                           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Apache Kafka

```
┌─────────────────────────────────────────────────────────┐
│                     APACHE KAFKA                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Тип: Distributed Event Streaming Platform              │
│  Модель: Append-only log                                │
│                                                         │
│  Архитектура:                                           │
│                                                         │
│  Producer ──► Topic ──► Consumer Group                  │
│                │                                        │
│                │ (partitions)                           │
│                │                                        │
│  Topic: orders                                          │
│  ┌─────────────────────────────────────────┐            │
│  │ Partition 0: [msg1][msg2][msg3][msg4]   │            │
│  │ Partition 1: [msg5][msg6][msg7]         │            │
│  │ Partition 2: [msg8][msg9]               │            │
│  └─────────────────────────────────────────┘            │
│                                                         │
│  Consumer Group:                                        │
│  • Consumer 1 читает Partition 0                        │
│  • Consumer 2 читает Partition 1, 2                     │
│                                                         │
│  Offset: позиция чтения (consumer сам хранит)           │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Огромная пропускная способность (миллионы msg/sec)   │
│  • Сообщения хранятся (можно перечитать)                │
│  • Ordering в рамках partition                          │
│  • Масштабируемость                                     │
│                                                         │
│  ❌ Минусы:                                             │
│  • Сложность                                            │
│  • Нет приоритетов сообщений                            │
│  • Нет гибкой маршрутизации                             │
│                                                         │
│  Когда использовать:                                    │
│  • Event Sourcing                                       │
│  • Стриминг данных                                      │
│  • Большие объёмы                                       │
│  • Аналитика в реальном времени                         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Сравнение

| Характеристика | RabbitMQ | Kafka |
|----------------|----------|-------|
| **Модель** | Message Broker | Event Log |
| **Хранение** | Удаляется после чтения | Хранится (retention) |
| **Ordering** | Per queue | Per partition |
| **Throughput** | ~50K msg/sec | ~1M msg/sec |
| **Routing** | Гибкая | Простая (по ключу) |
| **Replay** | Нет | Да |
| **Use case** | Task queue, RPC | Event streaming, analytics |

---

## Паттерны использования

### Event-Driven Architecture

```
┌─────────────────────────────────────────────────────────┐
│             EVENT-DRIVEN ARCHITECTURE                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Идея: Сервисы общаются через события                   │
│                                                         │
│  ┌─────────────┐                                        │
│  │Order Service│                                        │
│  └──────┬──────┘                                        │
│         │                                               │
│         │ OrderCreated event                            │
│         ▼                                               │
│  ┌─────────────────────────────────────────────┐        │
│  │              Message Broker                  │        │
│  └──────────────────┬──────────────────────────┘        │
│                     │                                   │
│         ┌───────────┼───────────┐                       │
│         ▼           ▼           ▼                       │
│  ┌───────────┐ ┌───────────┐ ┌───────────┐              │
│  │ Inventory │ │  Payment  │ │   Email   │              │
│  │  Service  │ │  Service  │ │  Service  │              │
│  └───────────┘ └───────────┘ └───────────┘              │
│                                                         │
│  Преимущества:                                          │
│  • Loose coupling                                       │
│  • Масштабируемость                                     │
│  • Легко добавить нового подписчика                     │
│                                                         │
│  Недостатки:                                            │
│  • Сложность отладки                                    │
│  • Eventual consistency                                 │
│  • Нужен мониторинг очередей                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### CQRS (Command Query Responsibility Segregation)

```
┌─────────────────────────────────────────────────────────┐
│                        CQRS                             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Идея: Разделить модели для чтения и записи             │
│                                                         │
│  ┌─────────────────────────────────────────────────┐    │
│  │                    CLIENT                        │    │
│  └───────────────────┬─────────────────────────────┘    │
│                      │                                  │
│           ┌──────────┴──────────┐                       │
│           ▼                     ▼                       │
│  ┌─────────────────┐   ┌─────────────────┐              │
│  │    COMMANDS     │   │     QUERIES     │              │
│  │  (Write Model)  │   │  (Read Model)   │              │
│  └────────┬────────┘   └────────┬────────┘              │
│           │                     │                       │
│           ▼                     ▼                       │
│  ┌─────────────────┐   ┌─────────────────┐              │
│  │   Write DB      │   │    Read DB      │              │
│  │ (normalized)    │   │ (denormalized)  │              │
│  └────────┬────────┘   └─────────────────┘              │
│           │                     ▲                       │
│           │    Events           │                       │
│           └─────────────────────┘                       │
│                                                         │
│  Write DB: Нормализованная, ACID                        │
│  Read DB: Денормализованная, оптимизирована для чтения  │
│                                                         │
│  Синхронизация через события                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Event Sourcing

```
┌─────────────────────────────────────────────────────────┐
│                   EVENT SOURCING                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Идея: Храним не состояние, а историю изменений         │
│                                                         │
│  Традиционный подход:                                   │
│  ┌─────────────────────────────────────────┐            │
│  │ Account: { id: 1, balance: 150 }        │            │
│  └─────────────────────────────────────────┘            │
│                                                         │
│  Event Sourcing:                                        │
│  ┌─────────────────────────────────────────┐            │
│  │ AccountCreated { id: 1 }                │            │
│  │ MoneyDeposited { amount: 100 }          │            │
│  │ MoneyDeposited { amount: 100 }          │            │
│  │ MoneyWithdrawn { amount: 50 }           │            │
│  └─────────────────────────────────────────┘            │
│                                                         │
│  Текущее состояние = replay всех событий                │
│  100 + 100 - 50 = 150                                   │
│                                                         │
│  ✅ Плюсы:                                              │
│  • Полная история                                       │
│  • Аудит бесплатно                                      │
│  • Можно "отмотать" время                               │
│  • Можно построить любую проекцию                       │
│                                                         │
│  ❌ Минусы:                                             │
│  • Сложность                                            │
│  • Eventual consistency                                 │
│  • Много данных                                         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Dead Letter Queue (DLQ)

```
┌─────────────────────────────────────────────────────────┐
│                 DEAD LETTER QUEUE                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Проблема: Что делать с сообщениями, которые не         │
│            удалось обработать?                          │
│                                                         │
│  Решение: Dead Letter Queue — очередь для "мёртвых"     │
│           сообщений                                     │
│                                                         │
│  ┌──────────┐     ┌─────────┐     ┌──────────┐          │
│  │ Producer │────►│  Queue  │────►│ Consumer │          │
│  └──────────┘     └────┬────┘     └────┬─────┘          │
│                        │               │                │
│                        │          (ошибка!)             │
│                        │               │                │
│                        │          retry 3 раза          │
│                        │               │                │
│                        │          (всё ещё ошибка)      │
│                        │               │                │
│                        ▼               ▼                │
│                   ┌─────────────────────────┐           │
│                   │   Dead Letter Queue     │           │
│                   └─────────────────────────┘           │
│                              │                          │
│                              ▼                          │
│                   Анализ, ручная обработка,             │
│                   алерты, исправление бага              │
│                                                         │
│  Типичные причины попадания в DLQ:                      │
│  • Невалидные данные                                    │
│  • Баг в consumer                                       │
│  • Недоступная зависимость                              │
│  • Таймаут обработки                                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Ключевые термины

| Термин | Определение |
|--------|-------------|
| **Producer** | Отправитель сообщений |
| **Consumer** | Получатель сообщений |
| **Broker** | Сервер очередей |
| **Topic** | Категория сообщений (Kafka) |
| **Queue** | Очередь сообщений (RabbitMQ) |
| **Partition** | Раздел топика для параллелизма |
| **Offset** | Позиция чтения в partition |
| **Consumer Group** | Группа consumers, читающих один топик |
| **At-least-once** | Гарантия доставки хотя бы раз |
| **Exactly-once** | Гарантия доставки ровно один раз |
| **DLQ** | Dead Letter Queue — очередь ошибочных сообщений |
| **Event Sourcing** | Хранение истории событий вместо состояния |
| **CQRS** | Разделение моделей чтения и записи |

---

## Что запомнить

1. **Очереди нужны для:** асинхронности, буферизации, decoupling
2. **RabbitMQ** — гибкая маршрутизация, небольшие объёмы
3. **Kafka** — большие объёмы, event streaming, replay
4. **At-least-once + идемпотентность** — лучший баланс
5. **DLQ обязателен** — иначе потеряешь сообщения
6. **Event-Driven** — loose coupling, но сложнее отлаживать

---

*Следующий файл: [15. Проектирование API](15_api_design.md)*

